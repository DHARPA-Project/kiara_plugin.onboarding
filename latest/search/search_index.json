{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiara plugin: onboarding \u00b6 This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara . Description \u00b6 kiara modules for data onboarding. Package content \u00b6 module_types \u00b6 onboard.zenodo_record : -- n/a -- operations \u00b6 onboard.zenodo_record : -- n/a -- Links \u00b6 Documentation: https://DHARPA-Project.github.io/kiara_plugin.onboarding Code: https://github.com/DHARPA-Project/kiara_plugin.onboarding","title":"Home"},{"location":"#kiara-plugin-onboarding","text":"This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara .","title":"kiara plugin: onboarding"},{"location":"#description","text":"kiara modules for data onboarding.","title":"Description"},{"location":"#package-content","text":"","title":"Package content"},{"location":"#module_types","text":"onboard.zenodo_record : -- n/a --","title":"module_types"},{"location":"#operations","text":"onboard.zenodo_record : -- n/a --","title":"operations"},{"location":"#links","text":"Documentation: https://DHARPA-Project.github.io/kiara_plugin.onboarding Code: https://github.com/DHARPA-Project/kiara_plugin.onboarding","title":"Links"},{"location":"SUMMARY/","text":"Home Package contents Usage Development API reference","title":"SUMMARY"},{"location":"development/","text":"Development \u00b6 Prepare development environment \u00b6 Using conda (recommended) \u00b6 conda create -n onboarding python=3.9 conda activate onboarding conda install -c conda-forge mamba # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below mamba install -c conda-forge -c dharpa kiara mamba install -c conda-forge -c dharpa kiara_plugin.core_types kiara_plugin.tabular # optional, adjust which plugin packages you depend on, those two are quite common Using Python venv \u00b6 Later, alligator. Check out the source code \u00b6 First, fork the kiara_plugin.onboarding repository into your personal Github account. Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.onboarding.git) to clone the repository locally: https://github.com/<YOUR_FORKED_GITHUB_ID>/kiara_plugin.onboarding Install the kiara plugin package into it \u00b6 cd kiara_plugin.onboarding pip install -e '.[all_dev]' Here we use the -e option for the pip install command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used. We also install a few additional requirements (the [all_dev] part in the command above) that are not strictly necessary for kiara itself, or this package, but help with various development-related tasks. Install some pre-commit check tooling (optional) \u00b6 This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a git commit in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes. pre-commit install pre-commit install --hook-type commit-msg In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/ Run kiara \u00b6 To check if everything works as expected and you can start adding/changing code in this repository, run any kiara command: kiara operation list -t onboarding If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#prepare-development-environment","text":"","title":"Prepare development environment"},{"location":"development/#using-conda-recommended","text":"conda create -n onboarding python=3.9 conda activate onboarding conda install -c conda-forge mamba # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below mamba install -c conda-forge -c dharpa kiara mamba install -c conda-forge -c dharpa kiara_plugin.core_types kiara_plugin.tabular # optional, adjust which plugin packages you depend on, those two are quite common","title":"Using conda (recommended)"},{"location":"development/#using-python-venv","text":"Later, alligator.","title":"Using Python venv"},{"location":"development/#check-out-the-source-code","text":"First, fork the kiara_plugin.onboarding repository into your personal Github account. Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.onboarding.git) to clone the repository locally: https://github.com/<YOUR_FORKED_GITHUB_ID>/kiara_plugin.onboarding","title":"Check out the source code"},{"location":"development/#install-the-kiara-plugin-package-into-it","text":"cd kiara_plugin.onboarding pip install -e '.[all_dev]' Here we use the -e option for the pip install command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used. We also install a few additional requirements (the [all_dev] part in the command above) that are not strictly necessary for kiara itself, or this package, but help with various development-related tasks.","title":"Install the kiara plugin package into it"},{"location":"development/#install-some-pre-commit-check-tooling-optional","text":"This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a git commit in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes. pre-commit install pre-commit install --hook-type commit-msg In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/","title":"Install some pre-commit check tooling (optional)"},{"location":"development/#run-kiara","text":"To check if everything works as expected and you can start adding/changing code in this repository, run any kiara command: kiara operation list -t onboarding If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.","title":"Run kiara"},{"location":"usage/","text":"Usage \u00b6 TO BE DONE","title":"Usage"},{"location":"usage/#usage","text":"TO BE DONE","title":"Usage"},{"location":"info/SUMMARY/","text":"module_types operations","title":"SUMMARY"},{"location":"info/module_types/","text":"onboard.zenodo_record \u00b6 Documentation -- n/a -- Author(s) Markus Binsteiner markus@frkl.io Context Tags onboarding Labels package : kiara_plugin.onboarding References source_repo : https://github.com/DHARPA-Project/kiara_plugin.onboarding documentation : https://DHARPA-Project.github.io/kiara_plugin.onboarding/ Module config schema Field Type Description Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. no defaults object Value defaults for this module. no metadata_filename string The filename for the zenodo metadata. no \"metadata.json\" Python class python_class_name ZenodoDownload python_module_name kiara_plugin.onboarding.modules full_name kiara_plugin.onboarding.modules.ZenodoDownload Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: ValueMap): import pyzenodo3 include_metadata = inputs . get_value_data( \"include_metadata\" ) doi = inputs . get_value_data( \"doi\" ) zen = pyzenodo3 . Zenodo() record = zen . find_record_by_doi(doi) path = FileBundle . create_tmp_dir() shutil . rmtree(path, ignore_errors = True ) path . mkdir() for file_data in record . data[ \"files\" ]: self . download_file(file_data, path) if include_metadata: metadata_filename = self . get_config_value( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes(orjson . dumps(record . data)) bundle = FileBundle . import_folder(path . as_posix()) outputs . set_value( \"file_bundle\" , bundle) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"module_types"},{"location":"info/module_types/#kiara_info.module_types.onboard.zenodo_record","text":"Documentation -- n/a -- Author(s) Markus Binsteiner markus@frkl.io Context Tags onboarding Labels package : kiara_plugin.onboarding References source_repo : https://github.com/DHARPA-Project/kiara_plugin.onboarding documentation : https://DHARPA-Project.github.io/kiara_plugin.onboarding/ Module config schema Field Type Description Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 constants object Value constants for this module. no defaults object Value defaults for this module. no metadata_filename string The filename for the zenodo metadata. no \"metadata.json\" Python class python_class_name ZenodoDownload python_module_name kiara_plugin.onboarding.modules full_name kiara_plugin.onboarding.modules.ZenodoDownload Processing source code \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def process (self, inputs: ValueMap, outputs: ValueMap): import pyzenodo3 include_metadata = inputs . get_value_data( \"include_metadata\" ) doi = inputs . get_value_data( \"doi\" ) zen = pyzenodo3 . Zenodo() record = zen . find_record_by_doi(doi) path = FileBundle . create_tmp_dir() shutil . rmtree(path, ignore_errors = True ) path . mkdir() for file_data in record . data[ \"files\" ]: self . download_file(file_data, path) if include_metadata: metadata_filename = self . get_config_value( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes(orjson . dumps(record . data)) bundle = FileBundle . import_folder(path . as_posix()) outputs . set_value( \"file_bundle\" , bundle) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"onboard.zenodo_record"},{"location":"info/operations/","text":"onboard.zenodo_record \u00b6 Documentation -- n/a -- Author(s) Markus Binsteiner markus@frkl.io Context Tags onboarding Labels package : kiara_plugin.onboarding References source_repo : https://github.com/DHARPA-Project/kiara_plugin.onboarding documentation : https://DHARPA-Project.github.io/kiara_plugin.onboarding/ Operation details Documentation -- n/a -- Inputs field name type description Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 doi string The doi of the record yes -- no default -- include_metadata boolean Whether to write the record metadata no True to a file 'metadata.json' and include it in the resulting file bundle. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 file_bundle file_bundle -- n/a --","title":"operations"},{"location":"info/operations/#kiara_info.operations.onboard.zenodo_record","text":"Documentation -- n/a -- Author(s) Markus Binsteiner markus@frkl.io Context Tags onboarding Labels package : kiara_plugin.onboarding References source_repo : https://github.com/DHARPA-Project/kiara_plugin.onboarding documentation : https://DHARPA-Project.github.io/kiara_plugin.onboarding/ Operation details Documentation -- n/a -- Inputs field name type description Required Default \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 doi string The doi of the record yes -- no default -- include_metadata boolean Whether to write the record metadata no True to a file 'metadata.json' and include it in the resulting file bundle. Outputs field name type description \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 file_bundle file_bundle -- n/a --","title":"onboard.zenodo_record"},{"location":"reference/SUMMARY/","text":"kiara_plugin onboarding data_types models modules pipelines","title":"SUMMARY"},{"location":"reference/kiara_plugin/onboarding/__init__/","text":"Top-level package for kiara_plugin.onboarding. KIARA_METADATA \u00b6 find_data_types : Union [ Type , Tuple , Callable ] \u00b6 find_model_classes : Union [ Type , Tuple , Callable ] \u00b6 find_modules : Union [ Type , Tuple , Callable ] \u00b6 find_pipelines : Union [ Type , Tuple , Callable ] \u00b6 get_version () \u00b6 Source code in onboarding/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__ Modules \u00b6 data_types \u00b6 This module contains the value type classes that are used in the kiara_plugin.onboarding package. models \u00b6 This module contains the metadata (and other) models that are used in the kiara_plugin.onboarding package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes. modules special \u00b6 Classes \u00b6 ZenodoDownload ( KiaraModule ) \u00b6 Source code in onboarding/modules/__init__.py class ZenodoDownload ( KiaraModule ): _module_type_name = \"onboard.zenodo_record\" _config_cls = ZenodoDownloadConfig def create_inputs_schema ( self , ) -> ValueSetSchema : metadata_filename = self . get_config_value ( \"metadata_filename\" ) return { \"doi\" : { \"type\" : \"string\" , \"doc\" : \"The doi of the record\" }, \"include_metadata\" : { \"type\" : \"boolean\" , \"doc\" : f \"Whether to write the record metadata to a file ' { metadata_filename } ' and include it in the resulting file bundle.\" , \"default\" : True , }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"file_bundle\" : { \"type\" : \"file_bundle\" , } } def download_file ( self , file_data : Mapping [ str , Any ], target_path : Path ): import httpx url = file_data [ \"links\" ][ \"self\" ] file_name = file_data [ \"key\" ] checksum = file_data [ \"checksum\" ][ 4 :] target_file = target_path / file_name if target_file . exists (): raise KiaraProcessingException ( f \"Can't download file, target path already exists: { target_path . as_posix () } .\" ) hash_md5 = hashlib . md5 () with open ( target_file , \"ab\" ) as file2 : with httpx . Client () as client : with client . stream ( \"GET\" , url ) as resp : for chunk in resp . iter_bytes (): hash_md5 . update ( chunk ) file2 . write ( chunk ) if checksum != hash_md5 . hexdigest (): raise KiaraProcessingException ( f \"Can't downloda file ' { file_name } ', invalid checksum: { checksum } != { hash_md5 . hexdigest () } \" ) return target_file def process ( self , inputs : ValueMap , outputs : ValueMap ): import pyzenodo3 include_metadata = inputs . get_value_data ( \"include_metadata\" ) doi = inputs . get_value_data ( \"doi\" ) zen = pyzenodo3 . Zenodo () record = zen . find_record_by_doi ( doi ) path = FileBundle . create_tmp_dir () shutil . rmtree ( path , ignore_errors = True ) path . mkdir () for file_data in record . data [ \"files\" ]: self . download_file ( file_data , path ) if include_metadata : metadata_filename = self . get_config_value ( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes ( orjson . dumps ( record . data )) bundle = FileBundle . import_folder ( path . as_posix ()) outputs . set_value ( \"file_bundle\" , bundle ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in onboarding/modules/__init__.py class ZenodoDownloadConfig ( KiaraModuleConfig ): metadata_filename : str = Field ( description = \"The filename for the zenodo metadata.\" , default = \"metadata.json\" ) Attributes \u00b6 metadata_filename : str pydantic-field \u00b6 The filename for the zenodo metadata. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in onboarding/modules/__init__.py def create_inputs_schema ( self , ) -> ValueSetSchema : metadata_filename = self . get_config_value ( \"metadata_filename\" ) return { \"doi\" : { \"type\" : \"string\" , \"doc\" : \"The doi of the record\" }, \"include_metadata\" : { \"type\" : \"boolean\" , \"doc\" : f \"Whether to write the record metadata to a file ' { metadata_filename } ' and include it in the resulting file bundle.\" , \"default\" : True , }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in onboarding/modules/__init__.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"file_bundle\" : { \"type\" : \"file_bundle\" , } } download_file ( self , file_data , target_path ) \u00b6 Source code in onboarding/modules/__init__.py def download_file ( self , file_data : Mapping [ str , Any ], target_path : Path ): import httpx url = file_data [ \"links\" ][ \"self\" ] file_name = file_data [ \"key\" ] checksum = file_data [ \"checksum\" ][ 4 :] target_file = target_path / file_name if target_file . exists (): raise KiaraProcessingException ( f \"Can't download file, target path already exists: { target_path . as_posix () } .\" ) hash_md5 = hashlib . md5 () with open ( target_file , \"ab\" ) as file2 : with httpx . Client () as client : with client . stream ( \"GET\" , url ) as resp : for chunk in resp . iter_bytes (): hash_md5 . update ( chunk ) file2 . write ( chunk ) if checksum != hash_md5 . hexdigest (): raise KiaraProcessingException ( f \"Can't downloda file ' { file_name } ', invalid checksum: { checksum } != { hash_md5 . hexdigest () } \" ) return target_file process ( self , inputs , outputs ) \u00b6 Source code in onboarding/modules/__init__.py def process ( self , inputs : ValueMap , outputs : ValueMap ): import pyzenodo3 include_metadata = inputs . get_value_data ( \"include_metadata\" ) doi = inputs . get_value_data ( \"doi\" ) zen = pyzenodo3 . Zenodo () record = zen . find_record_by_doi ( doi ) path = FileBundle . create_tmp_dir () shutil . rmtree ( path , ignore_errors = True ) path . mkdir () for file_data in record . data [ \"files\" ]: self . download_file ( file_data , path ) if include_metadata : metadata_filename = self . get_config_value ( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes ( orjson . dumps ( record . data )) bundle = FileBundle . import_folder ( path . as_posix ()) outputs . set_value ( \"file_bundle\" , bundle ) ZenodoDownloadConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in onboarding/modules/__init__.py class ZenodoDownloadConfig ( KiaraModuleConfig ): metadata_filename : str = Field ( description = \"The filename for the zenodo metadata.\" , default = \"metadata.json\" ) Attributes \u00b6 metadata_filename : str pydantic-field \u00b6 The filename for the zenodo metadata. pipelines special \u00b6 Default (empty) module that is used as a base path for pipelines contained in this package.","title":"onboarding"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.KIARA_METADATA","text":"","title":"KIARA_METADATA"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.find_data_types","text":"","title":"find_data_types"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.find_model_classes","text":"","title":"find_model_classes"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.find_modules","text":"","title":"find_modules"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.find_pipelines","text":"","title":"find_pipelines"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.get_version","text":"Source code in onboarding/__init__.py def get_version (): from pkg_resources import DistributionNotFound , get_distribution try : # Change here if project is renamed and does not equal the package name dist_name = __name__ __version__ = get_distribution ( dist_name ) . version except DistributionNotFound : try : version_file = os . path . join ( os . path . dirname ( __file__ ), \"version.txt\" ) if os . path . exists ( version_file ): with open ( version_file , encoding = \"utf-8\" ) as vf : __version__ = vf . read () else : __version__ = \"unknown\" except ( Exception ): pass if __version__ is None : __version__ = \"unknown\" return __version__","title":"get_version()"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding-modules","text":"","title":"Modules"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.data_types","text":"This module contains the value type classes that are used in the kiara_plugin.onboarding package.","title":"data_types"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.models","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.onboarding package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes.","title":"models"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.modules","text":"","title":"modules"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.modules-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload","text":"Source code in onboarding/modules/__init__.py class ZenodoDownload ( KiaraModule ): _module_type_name = \"onboard.zenodo_record\" _config_cls = ZenodoDownloadConfig def create_inputs_schema ( self , ) -> ValueSetSchema : metadata_filename = self . get_config_value ( \"metadata_filename\" ) return { \"doi\" : { \"type\" : \"string\" , \"doc\" : \"The doi of the record\" }, \"include_metadata\" : { \"type\" : \"boolean\" , \"doc\" : f \"Whether to write the record metadata to a file ' { metadata_filename } ' and include it in the resulting file bundle.\" , \"default\" : True , }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"file_bundle\" : { \"type\" : \"file_bundle\" , } } def download_file ( self , file_data : Mapping [ str , Any ], target_path : Path ): import httpx url = file_data [ \"links\" ][ \"self\" ] file_name = file_data [ \"key\" ] checksum = file_data [ \"checksum\" ][ 4 :] target_file = target_path / file_name if target_file . exists (): raise KiaraProcessingException ( f \"Can't download file, target path already exists: { target_path . as_posix () } .\" ) hash_md5 = hashlib . md5 () with open ( target_file , \"ab\" ) as file2 : with httpx . Client () as client : with client . stream ( \"GET\" , url ) as resp : for chunk in resp . iter_bytes (): hash_md5 . update ( chunk ) file2 . write ( chunk ) if checksum != hash_md5 . hexdigest (): raise KiaraProcessingException ( f \"Can't downloda file ' { file_name } ', invalid checksum: { checksum } != { hash_md5 . hexdigest () } \" ) return target_file def process ( self , inputs : ValueMap , outputs : ValueMap ): import pyzenodo3 include_metadata = inputs . get_value_data ( \"include_metadata\" ) doi = inputs . get_value_data ( \"doi\" ) zen = pyzenodo3 . Zenodo () record = zen . find_record_by_doi ( doi ) path = FileBundle . create_tmp_dir () shutil . rmtree ( path , ignore_errors = True ) path . mkdir () for file_data in record . data [ \"files\" ]: self . download_file ( file_data , path ) if include_metadata : metadata_filename = self . get_config_value ( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes ( orjson . dumps ( record . data )) bundle = FileBundle . import_folder ( path . as_posix ()) outputs . set_value ( \"file_bundle\" , bundle )","title":"ZenodoDownload"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload-classes","text":"_config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in onboarding/modules/__init__.py class ZenodoDownloadConfig ( KiaraModuleConfig ): metadata_filename : str = Field ( description = \"The filename for the zenodo metadata.\" , default = \"metadata.json\" ) Attributes \u00b6 metadata_filename : str pydantic-field \u00b6 The filename for the zenodo metadata.","title":"Classes"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload-methods","text":"create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in onboarding/modules/__init__.py def create_inputs_schema ( self , ) -> ValueSetSchema : metadata_filename = self . get_config_value ( \"metadata_filename\" ) return { \"doi\" : { \"type\" : \"string\" , \"doc\" : \"The doi of the record\" }, \"include_metadata\" : { \"type\" : \"boolean\" , \"doc\" : f \"Whether to write the record metadata to a file ' { metadata_filename } ' and include it in the resulting file bundle.\" , \"default\" : True , }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in onboarding/modules/__init__.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"file_bundle\" : { \"type\" : \"file_bundle\" , } } download_file ( self , file_data , target_path ) \u00b6 Source code in onboarding/modules/__init__.py def download_file ( self , file_data : Mapping [ str , Any ], target_path : Path ): import httpx url = file_data [ \"links\" ][ \"self\" ] file_name = file_data [ \"key\" ] checksum = file_data [ \"checksum\" ][ 4 :] target_file = target_path / file_name if target_file . exists (): raise KiaraProcessingException ( f \"Can't download file, target path already exists: { target_path . as_posix () } .\" ) hash_md5 = hashlib . md5 () with open ( target_file , \"ab\" ) as file2 : with httpx . Client () as client : with client . stream ( \"GET\" , url ) as resp : for chunk in resp . iter_bytes (): hash_md5 . update ( chunk ) file2 . write ( chunk ) if checksum != hash_md5 . hexdigest (): raise KiaraProcessingException ( f \"Can't downloda file ' { file_name } ', invalid checksum: { checksum } != { hash_md5 . hexdigest () } \" ) return target_file process ( self , inputs , outputs ) \u00b6 Source code in onboarding/modules/__init__.py def process ( self , inputs : ValueMap , outputs : ValueMap ): import pyzenodo3 include_metadata = inputs . get_value_data ( \"include_metadata\" ) doi = inputs . get_value_data ( \"doi\" ) zen = pyzenodo3 . Zenodo () record = zen . find_record_by_doi ( doi ) path = FileBundle . create_tmp_dir () shutil . rmtree ( path , ignore_errors = True ) path . mkdir () for file_data in record . data [ \"files\" ]: self . download_file ( file_data , path ) if include_metadata : metadata_filename = self . get_config_value ( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes ( orjson . dumps ( record . data )) bundle = FileBundle . import_folder ( path . as_posix ()) outputs . set_value ( \"file_bundle\" , bundle )","title":"Methods"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.modules.ZenodoDownloadConfig","text":"Source code in onboarding/modules/__init__.py class ZenodoDownloadConfig ( KiaraModuleConfig ): metadata_filename : str = Field ( description = \"The filename for the zenodo metadata.\" , default = \"metadata.json\" )","title":"ZenodoDownloadConfig"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.modules.ZenodoDownloadConfig-attributes","text":"metadata_filename : str pydantic-field \u00b6 The filename for the zenodo metadata.","title":"Attributes"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.pipelines","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"},{"location":"reference/kiara_plugin/onboarding/data_types/","text":"This module contains the value type classes that are used in the kiara_plugin.onboarding package.","title":"data_types"},{"location":"reference/kiara_plugin/onboarding/models/","text":"This module contains the metadata (and other) models that are used in the kiara_plugin.onboarding package. Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules. Metadata models must be a sub-class of kiara.metadata.MetadataModel . Other models usually sub-class a pydantic BaseModel or implement custom base classes.","title":"models"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/","text":"Classes \u00b6 ZenodoDownload ( KiaraModule ) \u00b6 Source code in onboarding/modules/__init__.py class ZenodoDownload ( KiaraModule ): _module_type_name = \"onboard.zenodo_record\" _config_cls = ZenodoDownloadConfig def create_inputs_schema ( self , ) -> ValueSetSchema : metadata_filename = self . get_config_value ( \"metadata_filename\" ) return { \"doi\" : { \"type\" : \"string\" , \"doc\" : \"The doi of the record\" }, \"include_metadata\" : { \"type\" : \"boolean\" , \"doc\" : f \"Whether to write the record metadata to a file ' { metadata_filename } ' and include it in the resulting file bundle.\" , \"default\" : True , }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"file_bundle\" : { \"type\" : \"file_bundle\" , } } def download_file ( self , file_data : Mapping [ str , Any ], target_path : Path ): import httpx url = file_data [ \"links\" ][ \"self\" ] file_name = file_data [ \"key\" ] checksum = file_data [ \"checksum\" ][ 4 :] target_file = target_path / file_name if target_file . exists (): raise KiaraProcessingException ( f \"Can't download file, target path already exists: { target_path . as_posix () } .\" ) hash_md5 = hashlib . md5 () with open ( target_file , \"ab\" ) as file2 : with httpx . Client () as client : with client . stream ( \"GET\" , url ) as resp : for chunk in resp . iter_bytes (): hash_md5 . update ( chunk ) file2 . write ( chunk ) if checksum != hash_md5 . hexdigest (): raise KiaraProcessingException ( f \"Can't downloda file ' { file_name } ', invalid checksum: { checksum } != { hash_md5 . hexdigest () } \" ) return target_file def process ( self , inputs : ValueMap , outputs : ValueMap ): import pyzenodo3 include_metadata = inputs . get_value_data ( \"include_metadata\" ) doi = inputs . get_value_data ( \"doi\" ) zen = pyzenodo3 . Zenodo () record = zen . find_record_by_doi ( doi ) path = FileBundle . create_tmp_dir () shutil . rmtree ( path , ignore_errors = True ) path . mkdir () for file_data in record . data [ \"files\" ]: self . download_file ( file_data , path ) if include_metadata : metadata_filename = self . get_config_value ( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes ( orjson . dumps ( record . data )) bundle = FileBundle . import_folder ( path . as_posix ()) outputs . set_value ( \"file_bundle\" , bundle ) Classes \u00b6 _config_cls ( KiaraModuleConfig ) private pydantic-model \u00b6 Source code in onboarding/modules/__init__.py class ZenodoDownloadConfig ( KiaraModuleConfig ): metadata_filename : str = Field ( description = \"The filename for the zenodo metadata.\" , default = \"metadata.json\" ) Attributes \u00b6 metadata_filename : str pydantic-field \u00b6 The filename for the zenodo metadata. Methods \u00b6 create_inputs_schema ( self ) \u00b6 Return the schema for this types' inputs. Source code in onboarding/modules/__init__.py def create_inputs_schema ( self , ) -> ValueSetSchema : metadata_filename = self . get_config_value ( \"metadata_filename\" ) return { \"doi\" : { \"type\" : \"string\" , \"doc\" : \"The doi of the record\" }, \"include_metadata\" : { \"type\" : \"boolean\" , \"doc\" : f \"Whether to write the record metadata to a file ' { metadata_filename } ' and include it in the resulting file bundle.\" , \"default\" : True , }, } create_outputs_schema ( self ) \u00b6 Return the schema for this types' outputs. Source code in onboarding/modules/__init__.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"file_bundle\" : { \"type\" : \"file_bundle\" , } } download_file ( self , file_data , target_path ) \u00b6 Source code in onboarding/modules/__init__.py def download_file ( self , file_data : Mapping [ str , Any ], target_path : Path ): import httpx url = file_data [ \"links\" ][ \"self\" ] file_name = file_data [ \"key\" ] checksum = file_data [ \"checksum\" ][ 4 :] target_file = target_path / file_name if target_file . exists (): raise KiaraProcessingException ( f \"Can't download file, target path already exists: { target_path . as_posix () } .\" ) hash_md5 = hashlib . md5 () with open ( target_file , \"ab\" ) as file2 : with httpx . Client () as client : with client . stream ( \"GET\" , url ) as resp : for chunk in resp . iter_bytes (): hash_md5 . update ( chunk ) file2 . write ( chunk ) if checksum != hash_md5 . hexdigest (): raise KiaraProcessingException ( f \"Can't downloda file ' { file_name } ', invalid checksum: { checksum } != { hash_md5 . hexdigest () } \" ) return target_file process ( self , inputs , outputs ) \u00b6 Source code in onboarding/modules/__init__.py def process ( self , inputs : ValueMap , outputs : ValueMap ): import pyzenodo3 include_metadata = inputs . get_value_data ( \"include_metadata\" ) doi = inputs . get_value_data ( \"doi\" ) zen = pyzenodo3 . Zenodo () record = zen . find_record_by_doi ( doi ) path = FileBundle . create_tmp_dir () shutil . rmtree ( path , ignore_errors = True ) path . mkdir () for file_data in record . data [ \"files\" ]: self . download_file ( file_data , path ) if include_metadata : metadata_filename = self . get_config_value ( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes ( orjson . dumps ( record . data )) bundle = FileBundle . import_folder ( path . as_posix ()) outputs . set_value ( \"file_bundle\" , bundle ) ZenodoDownloadConfig ( KiaraModuleConfig ) pydantic-model \u00b6 Source code in onboarding/modules/__init__.py class ZenodoDownloadConfig ( KiaraModuleConfig ): metadata_filename : str = Field ( description = \"The filename for the zenodo metadata.\" , default = \"metadata.json\" ) Attributes \u00b6 metadata_filename : str pydantic-field \u00b6 The filename for the zenodo metadata.","title":"modules"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload","text":"Source code in onboarding/modules/__init__.py class ZenodoDownload ( KiaraModule ): _module_type_name = \"onboard.zenodo_record\" _config_cls = ZenodoDownloadConfig def create_inputs_schema ( self , ) -> ValueSetSchema : metadata_filename = self . get_config_value ( \"metadata_filename\" ) return { \"doi\" : { \"type\" : \"string\" , \"doc\" : \"The doi of the record\" }, \"include_metadata\" : { \"type\" : \"boolean\" , \"doc\" : f \"Whether to write the record metadata to a file ' { metadata_filename } ' and include it in the resulting file bundle.\" , \"default\" : True , }, } def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"file_bundle\" : { \"type\" : \"file_bundle\" , } } def download_file ( self , file_data : Mapping [ str , Any ], target_path : Path ): import httpx url = file_data [ \"links\" ][ \"self\" ] file_name = file_data [ \"key\" ] checksum = file_data [ \"checksum\" ][ 4 :] target_file = target_path / file_name if target_file . exists (): raise KiaraProcessingException ( f \"Can't download file, target path already exists: { target_path . as_posix () } .\" ) hash_md5 = hashlib . md5 () with open ( target_file , \"ab\" ) as file2 : with httpx . Client () as client : with client . stream ( \"GET\" , url ) as resp : for chunk in resp . iter_bytes (): hash_md5 . update ( chunk ) file2 . write ( chunk ) if checksum != hash_md5 . hexdigest (): raise KiaraProcessingException ( f \"Can't downloda file ' { file_name } ', invalid checksum: { checksum } != { hash_md5 . hexdigest () } \" ) return target_file def process ( self , inputs : ValueMap , outputs : ValueMap ): import pyzenodo3 include_metadata = inputs . get_value_data ( \"include_metadata\" ) doi = inputs . get_value_data ( \"doi\" ) zen = pyzenodo3 . Zenodo () record = zen . find_record_by_doi ( doi ) path = FileBundle . create_tmp_dir () shutil . rmtree ( path , ignore_errors = True ) path . mkdir () for file_data in record . data [ \"files\" ]: self . download_file ( file_data , path ) if include_metadata : metadata_filename = self . get_config_value ( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes ( orjson . dumps ( record . data )) bundle = FileBundle . import_folder ( path . as_posix ()) outputs . set_value ( \"file_bundle\" , bundle )","title":"ZenodoDownload"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload-classes","text":"","title":"Classes"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload._config_cls","text":"Source code in onboarding/modules/__init__.py class ZenodoDownloadConfig ( KiaraModuleConfig ): metadata_filename : str = Field ( description = \"The filename for the zenodo metadata.\" , default = \"metadata.json\" )","title":"_config_cls"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload._config_cls-attributes","text":"metadata_filename : str pydantic-field \u00b6 The filename for the zenodo metadata.","title":"Attributes"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload-methods","text":"","title":"Methods"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload.create_inputs_schema","text":"Return the schema for this types' inputs. Source code in onboarding/modules/__init__.py def create_inputs_schema ( self , ) -> ValueSetSchema : metadata_filename = self . get_config_value ( \"metadata_filename\" ) return { \"doi\" : { \"type\" : \"string\" , \"doc\" : \"The doi of the record\" }, \"include_metadata\" : { \"type\" : \"boolean\" , \"doc\" : f \"Whether to write the record metadata to a file ' { metadata_filename } ' and include it in the resulting file bundle.\" , \"default\" : True , }, }","title":"create_inputs_schema()"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload.create_outputs_schema","text":"Return the schema for this types' outputs. Source code in onboarding/modules/__init__.py def create_outputs_schema ( self , ) -> ValueSetSchema : return { \"file_bundle\" : { \"type\" : \"file_bundle\" , } }","title":"create_outputs_schema()"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload.download_file","text":"Source code in onboarding/modules/__init__.py def download_file ( self , file_data : Mapping [ str , Any ], target_path : Path ): import httpx url = file_data [ \"links\" ][ \"self\" ] file_name = file_data [ \"key\" ] checksum = file_data [ \"checksum\" ][ 4 :] target_file = target_path / file_name if target_file . exists (): raise KiaraProcessingException ( f \"Can't download file, target path already exists: { target_path . as_posix () } .\" ) hash_md5 = hashlib . md5 () with open ( target_file , \"ab\" ) as file2 : with httpx . Client () as client : with client . stream ( \"GET\" , url ) as resp : for chunk in resp . iter_bytes (): hash_md5 . update ( chunk ) file2 . write ( chunk ) if checksum != hash_md5 . hexdigest (): raise KiaraProcessingException ( f \"Can't downloda file ' { file_name } ', invalid checksum: { checksum } != { hash_md5 . hexdigest () } \" ) return target_file","title":"download_file()"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownload.process","text":"Source code in onboarding/modules/__init__.py def process ( self , inputs : ValueMap , outputs : ValueMap ): import pyzenodo3 include_metadata = inputs . get_value_data ( \"include_metadata\" ) doi = inputs . get_value_data ( \"doi\" ) zen = pyzenodo3 . Zenodo () record = zen . find_record_by_doi ( doi ) path = FileBundle . create_tmp_dir () shutil . rmtree ( path , ignore_errors = True ) path . mkdir () for file_data in record . data [ \"files\" ]: self . download_file ( file_data , path ) if include_metadata : metadata_filename = self . get_config_value ( \"metadata_filename\" ) metadata_file = path / metadata_filename metadata_file . write_bytes ( orjson . dumps ( record . data )) bundle = FileBundle . import_folder ( path . as_posix ()) outputs . set_value ( \"file_bundle\" , bundle )","title":"process()"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownloadConfig","text":"Source code in onboarding/modules/__init__.py class ZenodoDownloadConfig ( KiaraModuleConfig ): metadata_filename : str = Field ( description = \"The filename for the zenodo metadata.\" , default = \"metadata.json\" )","title":"ZenodoDownloadConfig"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownloadConfig-attributes","text":"","title":"Attributes"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ZenodoDownloadConfig.metadata_filename","text":"The filename for the zenodo metadata.","title":"metadata_filename"},{"location":"reference/kiara_plugin/onboarding/pipelines/__init__/","text":"Default (empty) module that is used as a base path for pipelines contained in this package.","title":"pipelines"}]}