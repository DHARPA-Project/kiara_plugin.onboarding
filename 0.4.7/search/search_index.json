{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kiara plugin: onboarding","text":"<p>This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for Kiara.</p>"},{"location":"#description","title":"Description","text":"<p>kiara modules for data onboarding.</p>"},{"location":"#package-content","title":"Package content","text":""},{"location":"#module_types","title":"module_types","text":"<ul> <li> <p><code>import.file</code>: A generic module that imports a file from one of several possible sources.</p> </li> <li> <p><code>import.file_bundle</code>: A generic module that imports a file from one of several possible sources.</p> </li> <li> <p><code>onboard.zenodo_record</code>: Download a dataset from zenodo.org.</p> </li> </ul>"},{"location":"#kiara_model_types","title":"kiara_model_types","text":"<ul> <li> <p><code>onboarding.file.from.local_file</code>: -- n/a --</p> </li> <li> <p><code>onboarding.file.from.url</code>: -- n/a --</p> </li> <li> <p><code>onboarding.file.from.zenodo</code>: -- n/a --</p> </li> <li> <p><code>onboarding.file.from.github</code>: -- n/a --</p> </li> </ul>"},{"location":"#operations","title":"operations","text":"<ul> <li> <p><code>import.file</code>: A generic module that imports a file from one of several possible sources.</p> </li> <li> <p><code>import.file_bundle</code>: A generic module that imports a file from one of several possible sources.</p> </li> <li> <p><code>onboard.zenodo_record</code>: Download a dataset from zenodo.org.</p> </li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: https://DHARPA-Project.github.io/kiara_plugin.onboarding</li> <li>Code: https://github.com/DHARPA-Project/kiara_plugin.onboarding</li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Package contents</li> <li>Usage</li> <li>Development</li> <li>API reference</li> </ul>"},{"location":"development/","title":"Development","text":""},{"location":"development/#prepare-development-environment","title":"Prepare development environment","text":""},{"location":"development/#using-conda-recommended","title":"Using conda (recommended)","text":"<pre><code>conda create -n onboarding python=3.9\nconda activate onboarding\nconda install -c conda-forge mamba   # this is optional, but makes everything install related much faster, if you don't use it, replace 'mamba' with 'conda' below\nmamba install -c conda-forge -c dharpa kiara\nmamba install -c conda-forge -c dharpa kiara_plugin.core_types kiara_plugin.tabular   # optional, adjust which plugin packages you depend on, those two are quite common\n</code></pre>"},{"location":"development/#using-python-venv","title":"Using Python venv","text":"<p>Later, alligator.</p>"},{"location":"development/#check-out-the-source-code","title":"Check out the source code","text":"<p>First, fork the kiara_plugin.onboarding repository into your personal Github account.</p> <p>Then, use the resulting url (in my case: https://github.com/makkus/kiara_modules.onboarding.git) to clone the repository locally:</p> <pre><code>https://github.com/&lt;YOUR_FORKED_GITHUB_ID&gt;/kiara_plugin.onboarding\n</code></pre>"},{"location":"development/#install-the-kiara-plugin-package-into-it","title":"Install the kiara plugin package into it","text":"<pre><code>cd kiara_plugin.onboarding\npip install -e '.[all_dev]'\n</code></pre> <p>Here we use the <code>-e</code> option for the <code>pip install</code> command. This installs the local folder as a package in development mode into the current environment. Development mode makes it so that if you change any of the files in this folder, the Python environment will pick it up automatically, and whenever you run anything in this environment the latest version of your code/files are used.</p> <p>We also install a few additional requirements  (the <code>[all_dev]</code> part in the command above) that are not strictly necessary for <code>kiara</code> itself, or this package, but help with various development-related tasks.</p>"},{"location":"development/#install-some-pre-commit-check-tooling-optional","title":"Install some pre-commit check tooling (optional)","text":"<p>This step is optional, but helps with keeping the code clean and CI from failing. By installing pre-commit hooks like here, whenever you do a <code>git commit</code> in this repo, a series of checks and cleanup tasks are run, until everything is in a state that will hopefully make Github Actions not complain when you push your changes.</p> <pre><code>pre-commit install\npre-commit install --hook-type commit-msg\n</code></pre> <p>In addition to some Python-specific checks and cleanup tasks, this will also check your commit message so it's in line with the suggested format: https://www.conventionalcommits.org/en/v1.0.0/</p>"},{"location":"development/#run-kiara","title":"Run kiara","text":"<p>To check if everything works as expected and you can start adding/changing code in this repository, run any <code>kiara</code> command:</p> <pre><code>kiara operation list -t onboarding\n</code></pre> <p>If everything is set up correctly, the output of this command should contain a few operations that are implemented in this repository.</p>"},{"location":"usage/","title":"Usage","text":"<p>TO BE DONE</p>"},{"location":"info/SUMMARY/","title":"SUMMARY","text":"<ul> <li>module_types</li> <li>kiara_model_types</li> <li>operations</li> </ul>"},{"location":"info/kiara_model_types/","title":"kiara_model_types","text":""},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.onboarding.file.from.local_file","title":"<code>onboarding.file.from.local_file</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                                      \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         onboarding                                        \n               Labels       package: kiara_plugin.onboarding                  \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    FileFromLocalModel                        \n               python_module_name   kiara_plugin.onboarding.models            \n               full_name            kiara_plugin.onboarding.models.FileFro\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.onboarding.file.from.url","title":"<code>onboarding.file.from.url</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                                      \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         onboarding                                        \n               Labels       package: kiara_plugin.onboarding                  \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    FileFromRemoteModel                       \n               python_module_name   kiara_plugin.onboarding.models            \n               full_name            kiara_plugin.onboarding.models.FileFro\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.onboarding.file.from.zenodo","title":"<code>onboarding.file.from.zenodo</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                                      \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         onboarding                                        \n               Labels       package: kiara_plugin.onboarding                  \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    FileFromZenodoModel                       \n               python_module_name   kiara_plugin.onboarding.models            \n               full_name            kiara_plugin.onboarding.models.FileFro\u2026   \n              </pre>"},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.onboarding.file.from.github","title":"<code>onboarding.file.from.github</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    -- n/a --                                                      \n              Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                             \n Context                                                                        \n  Tags         onboarding                                        \n               Labels       package: kiara_plugin.onboarding                  \n               References   source_repo:                                      \n              https://github.com/DHARPA-Project/kiara_plugin\u2026   \n documentation:                                    \n              https://DHARPA-Project.github.io/kiara_plugin.\u2026   \n Python class                                                                   \n  python_class_name    FileFromGithubModel                       \n               python_module_name   kiara_plugin.onboarding.models            \n               full_name            kiara_plugin.onboarding.models.FileFro\u2026   \n              </pre>"},{"location":"info/module_types/","title":"module_types","text":""},{"location":"info/module_types/#kiara_info.module_types.import.file","title":"<code>import.file</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    A generic module that imports a file from one of      \n                          several possible sources.                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         onboarding                               \n                        Labels       package: kiara_plugin.onboarding         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type      Descrip\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          attach_m\u2026   boolean   Whether    no                   \n                                                to                              \n                                                attach                          \n                                                metadat\u2026                        \n                          constants   object    Value      no                   \n                                                constan\u2026                        \n                                                for this                        \n                                                module.                         \n                          defaults    object    Value      no                   \n                                                defaults                        \n                                                for this                        \n                                                module.                         \n                          onboard_\u2026   string    The name   no                   \n                                                of the                          \n                                                type of                         \n                                                onboard\u2026                        \n                       Python class                                                                   \n  python_class_name    OnboardFileModule                \n                        python_module_name   kiara_plugin.onboarding.modul\u2026   \n                        full_name            kiara_plugin.onboarding.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class OnboardFileModule(KiaraModule):                 \n \"\"\"A generic module that imports a file from o\u2026   \n     _module_type_name = \"import.file\"                 \n     _config_cls = OnboardFileConfig                   \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result = {                                    \n \"source\": {                               \n \"type\": \"string\",                     \n \"doc\": \"The source uri of the file\u2026   \n \"optional\": False,                    \n             },                                        \n \"file_name\": {                            \n \"type\": \"string\",                     \n \"doc\": \"The file name to use for t\u2026   \n \"optional\": True,                     \n             },                                        \n         }                                             \n if self.get_config_value(\"attach_metadata\"\u2026   \n             result[\"attach_metadata\"] = {             \n \"type\": \"boolean\",                    \n \"doc\": \"Whether to attach onboardi\u2026   \n \"default\": True,                      \n             }                                         \n         onboard_type: Union[str, None] = self.get_\u2026   \n if not onboard_type:                          \n             onboard_model_cls = None                  \n else:                                         \n             onboard_model_cls = get_onboard_model_\u2026   \n if not onboard_model_cls:                     \n             available = (                             \n                 ModelRegistry.instance()              \n .get_models_of_type(OnboardDataMod\u2026   \n .item_infos.keys()                    \n             )                                         \n if not available:                         \n raise KiaraException(msg=\"No onboa\u2026   \n             idx = len(ONBOARDING_MODEL_NAME_PREFIX)   \n             allowed = sorted((x[idx:] for x in ava\u2026   \n             result[\"onboard_type\"] = {                \n \"type\": \"string\",                     \n \"type_config\": {\"allowed_strings\":\u2026   \n \"doc\": \"The type of onboarding to \u2026   \n \", \".join(allowed)                \n                 ),                                    \n \"optional\": True,                     \n             }                                         \n elif onboard_model_cls.get_config_fields():   \n             result = {                                \n \"onboard_config\": {                   \n \"type\": \"kiara_model\",            \n \"type_config\": {                  \n \"kiara_model_id\": self.get\u2026   \n                     },                                \n                 }                                     \n             }                                         \n return result                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result = {\"file\": {\"type\": \"file\", \"doc\": \u2026   \n return result                                 \n def process(self, inputs: ValueMap, outputs: V\u2026   \n         onboard_type = self.get_config_value(\"onbo\u2026   \n         source: str = inputs.get_value_data(\"sourc\u2026   \n         file_name: Union[str, None] = inputs.get_v\u2026   \n if not onboard_type:                          \n             user_input_onboard_type = inputs.get_v\u2026   \n if user_input_onboard_type:               \n                 onboard_type = (                      \n f\"{ONBOARDING_MODEL_NAME_PREFI\u2026   \n                 )                                     \n         attach_metadata = self.get_config_value(\"a\u2026   \n if attach_metadata is None:                   \n             attach_metadata = inputs.get_value_dat\u2026   \n         data = onboard_file(                          \n             source=source,                            \n             file_name=file_name,                      \n             onboard_type=onboard_type,                \n             attach_metadata=attach_metadata,          \n         )                                             \n         outputs.set_value(\"file\", data)               \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.import.file_bundle","title":"<code>import.file_bundle</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    A generic module that imports a file from one of      \n                          several possible sources.                             \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         onboarding                               \n                        Labels       package: kiara_plugin.onboarding         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field       Type      Descrip\u2026   Required   Default   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          attach_m\u2026   boolean   Whether    no                   \n                                                to                              \n                                                attach                          \n                                                onboard\u2026                        \n                                                metadat\u2026                        \n                          constants   object    Value      no                   \n                                                constan\u2026                        \n                                                for this                        \n                                                module.                         \n                          defaults    object    Value      no                   \n                                                defaults                        \n                                                for this                        \n                                                module.                         \n                          exclude_\u2026   array     Exclude    no                   \n                                                directo\u2026                        \n                                                that end                        \n                                                with one                        \n                                                of those                        \n                                                tokens.                         \n                          exclude_\u2026   array     File       no                   \n                                                types to                        \n                                                include.                        \n                          include_\u2026   array     File       no                   \n                                                types to                        \n                                                include.                        \n                          onboard_\u2026   string    The name   no                   \n                                                of the                          \n                                                type of                         \n                                                onboard\u2026                        \n                          sub_path    string    The sub    no                   \n                                                path to                         \n                                                use.                            \n                       Python class                                                                   \n  python_class_name    OnboardFileBundleModule          \n                        python_module_name   kiara_plugin.onboarding.modul\u2026   \n                        full_name            kiara_plugin.onboarding.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class OnboardFileBundleModule(KiaraModule):           \n \"\"\"A generic module that imports a file from o\u2026   \n     _module_type_name = \"import.file_bundle\"          \n     _config_cls = OnboardFileBundleConfig             \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result = {                                    \n \"source\": {                               \n \"type\": \"string\",                     \n \"doc\": \"The source uri of the file\u2026   \n \"optional\": False,                    \n             }                                         \n         }                                             \n if self.get_config_value(\"attach_metadata\"\u2026   \n             result[\"attach_metadata\"] = {             \n \"type\": \"boolean\",                    \n \"doc\": \"Whether to attach onboardi\u2026   \n \"default\": True,                      \n             }                                         \n if self.get_config_value(\"sub_path\") is No\u2026   \n             result[\"sub_path\"] = {                    \n \"type\": \"string\",                     \n \"doc\": \"The sub path to use. If no\u2026   \n \"optional\": True,                     \n             }                                         \n if self.get_config_value(\"include_files\") \u2026   \n             result[\"include_files\"] = {               \n \"type\": \"list\",                       \n \"doc\": \"Include files that end wit\u2026   \n \"optional\": True,                     \n             }                                         \n if self.get_config_value(\"exclude_files\") \u2026   \n             result[\"exclude_files\"] = {               \n \"type\": \"list\",                       \n \"doc\": \"Exclude files that end wit\u2026   \n \"optional\": True,                     \n             }                                         \n if self.get_config_value(\"exclude_dirs\") i\u2026   \n             result[\"exclude_dirs\"] = {                \n \"type\": \"list\",                       \n \"doc\": \"Exclude directories that e\u2026   \n \"optional\": True,                     \n             }                                         \n         onboard_type: Union[str, None] = self.get_\u2026   \n if not onboard_type:                          \n             onboard_model_cls = None                  \n else:                                         \n             onboard_model_cls = get_onboard_model_\u2026   \n if not onboard_model_cls:                     \n             available = (                             \n                 ModelRegistry.instance()              \n .get_models_of_type(OnboardDataMod\u2026   \n .item_infos.keys()                    \n             )                                         \n if not available:                         \n raise KiaraException(msg=\"No onboa\u2026   \n             idx = len(ONBOARDING_MODEL_NAME_PREFIX)   \n             allowed = sorted((x[idx:] for x in ava\u2026   \n             result[\"onboard_type\"] = {                \n \"type\": \"string\",                     \n \"type_config\": {\"allowed_strings\":\u2026   \n \"doc\": \"The type of onboarding to \u2026   \n \", \".join(allowed)                \n                 ),                                    \n \"optional\": True,                     \n             }                                         \n elif onboard_model_cls.get_config_fields():   \n             result = {                                \n \"onboard_config\": {                   \n \"type\": \"kiara_model\",            \n \"type_config\": {                  \n \"kiara_model_id\": self.get\u2026   \n                     },                                \n                 }                                     \n             }                                         \n return result                                 \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         result = {                                    \n \"file_bundle\": {                          \n \"type\": \"file_bundle\",                \n \"doc\": \"The file_bundle that was o\u2026   \n             }                                         \n         }                                             \n return result                                 \n def process(self, inputs: ValueMap, outputs: V\u2026   \n         onboard_type = self.get_config_value(\"onbo\u2026   \n         source: str = inputs.get_value_data(\"sourc\u2026   \n if onboard_type:                              \n             user_input_onboard_type = inputs.get_v\u2026   \n if not user_input_onboard_type:           \n                 onboard_type = (                      \n f\"{ONBOARDING_MODEL_NAME_PREFI\u2026   \n                 )                                     \n         sub_path = self.get_config_value(\"sub_path\u2026   \n if sub_path is None:                          \n             sub_path = inputs.get_value_data(\"sub_\u2026   \n         include = self.get_config_value(\"include_f\u2026   \n if include is None:                           \n             _include = inputs.get_value_data(\"incl\u2026   \n if _include:                              \n                 include = _include.list_data          \n         exclude = self.get_config_value(\"exclude_f\u2026   \n if exclude is None:                           \n             _exclude = inputs.get_value_data(\"excl\u2026   \n if _exclude:                              \n                 exclude = _exclude.list_data          \n         exclude_dirs = self.get_config_value(\"excl\u2026   \n if exclude_dirs is None:                      \n             _exclude_dirs = inputs.get_value_data(\u2026   \n if _exclude_dirs:                         \n                 exclude_dirs = _exclude_dirs.list_\u2026   \n         import_config_data = {                        \n \"sub_path\": sub_path,                     \n         }                                             \n if include:                                   \n             import_config_data[\"include_files\"] = \u2026   \n if exclude:                                   \n             import_config_data[\"exclude_files\"] = \u2026   \n if exclude_dirs:                              \n             import_config_data[\"exclude_dirs\"] = e\u2026   \n         import_config = FolderImportConfig(**impor\u2026   \n         attach_metadata = self.get_config_value(\"a\u2026   \n if attach_metadata is None:                   \n             attach_metadata = inputs.get_value_dat\u2026   \n         imported_bundle = onboard_file_bundle(        \n             source=source,                            \n             import_config=import_config,              \n             onboard_type=onboard_type,                \n             attach_metadata=attach_metadata,          \n         )                                             \n         outputs.set_value(\"file_bundle\", imported_\u2026   \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/module_types/#kiara_info.module_types.onboard.zenodo_record","title":"<code>onboard.zenodo_record</code>","text":"<pre>                                                                                \n Documentation                                                                  \n    Download a dataset from zenodo.org.                   \n                       Author(s)                                                                      \n    Markus Binsteiner   markus@frkl.io                    \n Context                                                                        \n  Tags         onboarding                               \n                        Labels       package: kiara_plugin.onboarding         \n                        References   source_repo:                             \n                       https://github.com/DHARPA-Project/kia\u2026   \n documentation:                           \n                       https://DHARPA-Project.github.io/kiar\u2026   \n Module config schema                                                           \n  Field      Type     Descript\u2026   Required   Default    \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                          constan\u2026   object   Value       no                    \n                                              constants                         \n                                              for this                          \n                                              module.                           \n                          defaults   object   Value       no                    \n                                              defaults                          \n                                              for this                          \n                                              module.                           \n                          metadat\u2026   string   The         no         \"metada\u2026   \n                                              filename                          \n                                              for the                           \n                                              zenodo                            \n                                              metadata.                         \n                       Python class                                                                   \n  python_class_name    ZenodoDownload                   \n                        python_module_name   kiara_plugin.onboarding.modul\u2026   \n                        full_name            kiara_plugin.onboarding.modul\u2026   \n                       Processing source code  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                       class ZenodoDownload(KiaraModule):                    \n \"\"\"Download a dataset from zenodo.org.\"\"\"         \n     _module_type_name = \"onboard.zenodo_record\"       \n     _config_cls = ZenodoDownloadConfig                \n def create_inputs_schema(                         \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n         metadata_filename = self.get_config_value(\u2026   \n return {                                      \n \"doi\": {\"type\": \"string\", \"doc\": \"The \u2026   \n \"include_metadata\": {                     \n \"type\": \"boolean\",                    \n \"doc\": f\"Whether to write the reco\u2026   \n \"default\": True,                      \n             },                                        \n         }                                             \n def create_outputs_schema(                        \n         self,                                         \n     ) -&gt; ValueMapSchema:                              \n return {                                      \n \"file_bundle\": {                          \n \"type\": \"file_bundle\",                \n             }                                         \n         }                                             \n def download_file(self, file_data: Mapping[str\u2026   \n import httpx                                  \n         url = file_data[\"links\"][\"self\"]              \n         file_name = file_data[\"key\"]                  \n         checksum = file_data[\"checksum\"][4:]          \n         target_file = target_path / file_name         \n if target_file.exists():                      \n raise KiaraProcessingException(           \n f\"Can't download file, target path\u2026   \n             )                                         \n         hash_md5 = hashlib.md5()  # noqa              \n with open(target_file, \"ab\") as file2:        \n with httpx.Client() as client:            \n with client.stream(\"GET\", url) as \u2026   \n for chunk in resp.iter_bytes():   \n                         hash_md5.update(chunk)        \n                         file2.write(chunk)            \n if checksum != hash_md5.hexdigest():          \n raise KiaraProcessingException(           \n f\"Can't downloda file '{file_name}\u2026   \n             )                                         \n return target_file                            \n def process(self, inputs: ValueMap, outputs: V\u2026   \n import pyzenodo3                              \n         include_metadata = inputs.get_value_data(\"\u2026   \n         doi = inputs.get_value_data(\"doi\")            \n         zen = pyzenodo3.Zenodo()                      \n         record = zen.find_record_by_doi(doi)          \n         path = KiaraFileBundle.create_tmp_dir()       \n         shutil.rmtree(path, ignore_errors=True)       \n         path.mkdir()                                  \n for file_data in record.data[\"files\"]:        \n             self.download_file(file_data, path)       \n if include_metadata:                          \n             metadata_filename = self.get_config_va\u2026   \n             metadata_file = path / metadata_filena\u2026   \n             metadata_file.write_bytes(orjson.dumps\u2026   \n         bundle = KiaraFileBundle.import_folder(pat\u2026   \n         outputs.set_value(\"file_bundle\", bundle)      \n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \n                                                                                \n</pre>"},{"location":"info/operations/","title":"operations","text":""},{"location":"info/operations/#kiara_info.operations.import.file","title":"<code>import.file</code>","text":"Documentation <p>A generic module that imports a file from one of several possible sources.</p> Inputs field name type description required default source string The source uri of the file to be onboarded. yes file_name string The file name to use for the onboarded file (defaults to source file name if possible). no attach_metadata boolean Whether to attach onboarding metadata to the result file. no True onboard_type string The type of onboarding to use. Allowed: github, local_file, url, zenodo no Outputs field name type description required default file file The file that was onboarded. yes"},{"location":"info/operations/#kiara_info.operations.import.file_bundle","title":"<code>import.file_bundle</code>","text":"Documentation <p>A generic module that imports a file from one of several possible sources.</p> Inputs field name type description required default source string The source uri of the file to be onboarded. yes attach_metadata boolean Whether to attach onboarding metadata. no True sub_path string The sub path to use. If not specified, the root of the source folder will be used. no include_files list Include files that end with one of those tokens. If not specified, all file extensions are included. no exclude_files list Exclude files that end with one of those tokens. If not specified, no file extensions are excluded. no exclude_dirs list Exclude directories that end with one of those tokens. If not specified, no directories are excluded. no onboard_type string The type of onboarding to use. Allowed: github, local_file, url, zenodo no Outputs field name type description required default file_bundle file_bundle The file_bundle that was onboarded. yes"},{"location":"info/operations/#kiara_info.operations.onboard.zenodo_record","title":"<code>onboard.zenodo_record</code>","text":"Documentation <p>Download a dataset from zenodo.org.</p> Inputs field name type description required default doi string The doi of the record yes include_metadata boolean Whether to write the record metadata to a file 'metadata.json' and include it in the resulting file bundle. no True Outputs field name type description required default file_bundle file_bundle -- n/a -- yes"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>kiara_plugin<ul> <li>onboarding<ul> <li>data_types</li> <li>models</li> <li>modules<ul> <li>files<ul> <li>import_file</li> <li>import_file_bundle</li> </ul> </li> <li>zenodo</li> </ul> </li> <li>pipelines</li> <li>utils<ul> <li>download</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/kiara_plugin/onboarding/__init__/","title":"onboarding","text":"<p>Top-level package for kiara_plugin.onboarding.</p>"},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': __author__, 'email': __email__}], 'description': 'Kiara modules for: onboarding', 'references': {'source_repo': {'desc': 'The module package git repository.', 'url': 'https://github.com/DHARPA-Project/kiara_plugin.onboarding'}, 'documentation': {'desc': 'The url for the module package documentation.', 'url': 'https://DHARPA-Project.github.io/kiara_plugin.onboarding/'}}, 'tags': ['onboarding'], 'labels': {'package': 'kiara_plugin.onboarding'}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.find_modules","title":"<code>find_modules: KiaraEntryPointItem = (find_kiara_modules_under, 'kiara_plugin.onboarding.modules')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.find_model_classes","title":"<code>find_model_classes: KiaraEntryPointItem = (find_kiara_model_classes_under, 'kiara_plugin.onboarding.models')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.find_data_types","title":"<code>find_data_types: KiaraEntryPointItem = (find_data_types_under, 'kiara_plugin.onboarding.data_types')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.find_pipelines","title":"<code>find_pipelines: KiaraEntryPointItem = (find_pipeline_base_path_for_module, 'kiara_plugin.onboarding.pipelines', KIARA_METADATA)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/__init__/#kiara_plugin.onboarding.get_version","title":"<code>get_version()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/__init__.py</code> <pre><code>def get_version():\n    from pkg_resources import DistributionNotFound, get_distribution\n\n    try:\n        # Change here if project is renamed and does not equal the package name\n        dist_name = __name__\n        __version__ = get_distribution(dist_name).version\n    except DistributionNotFound:\n\n        try:\n            version_file = os.path.join(os.path.dirname(__file__), \"version.txt\")\n\n            if os.path.exists(version_file):\n                with open(version_file, encoding=\"utf-8\") as vf:\n                    __version__ = vf.read()\n            else:\n                __version__ = \"unknown\"\n\n        except (Exception):\n            pass\n\n        if __version__ is None:\n            __version__ = \"unknown\"\n\n    return __version__\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/data_types/","title":"data_types","text":"<p>This module contains the value type classes that are used in the <code>kiara_plugin.onboarding</code> package.</p>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/","title":"models","text":"<p>This module contains the metadata (and other) models that are used in the <code>kiara_plugin.onboarding</code> package.</p> <p>Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules.</p> <p>Metadata models must be a sub-class of kiara.metadata.MetadataModel. Other models usually sub-class a pydantic BaseModel or implement custom base classes.</p>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.OnboardDataModel","title":"<code>OnboardDataModel</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>class OnboardDataModel(KiaraModel):\n\n    _kiara_model_id: str = None  # type: ignore\n\n    @classmethod\n    def get_config_fields(cls) -&gt; List[str]:\n        return sorted(cls.__fields__.keys())\n\n    @classmethod\n    @abstractmethod\n    def accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n        pass\n\n    @classmethod\n    def accepts_bundle_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n        return cls.accepts_uri(uri)\n\n    @abstractmethod\n    def retrieve(\n        self, uri: str, file_name: Union[None, str], attach_metadata: bool\n    ) -&gt; KiaraFile:\n        pass\n\n    def retrieve_bundle(\n        self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n    ) -&gt; KiaraFileBundle:\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.OnboardDataModel-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.OnboardDataModel.get_config_fields","title":"<code>get_config_fields() -&gt; List[str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@classmethod\ndef get_config_fields(cls) -&gt; List[str]:\n    return sorted(cls.__fields__.keys())\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.OnboardDataModel.accepts_uri","title":"<code>accepts_uri(uri: str) -&gt; Tuple[bool, str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@classmethod\n@abstractmethod\ndef accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n    pass\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.OnboardDataModel.accepts_bundle_uri","title":"<code>accepts_bundle_uri(uri: str) -&gt; Tuple[bool, str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@classmethod\ndef accepts_bundle_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n    return cls.accepts_uri(uri)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.OnboardDataModel.retrieve","title":"<code>retrieve(uri: str, file_name: Union[None, str], attach_metadata: bool) -&gt; KiaraFile</code>  <code>abstractmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@abstractmethod\ndef retrieve(\n    self, uri: str, file_name: Union[None, str], attach_metadata: bool\n) -&gt; KiaraFile:\n    pass\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.OnboardDataModel.retrieve_bundle","title":"<code>retrieve_bundle(uri: str, import_config: FolderImportConfig, attach_metadata: bool) -&gt; KiaraFileBundle</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>def retrieve_bundle(\n    self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n) -&gt; KiaraFileBundle:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromLocalModel","title":"<code>FileFromLocalModel</code>","text":"<p>         Bases: <code>OnboardDataModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>class FileFromLocalModel(OnboardDataModel):\n\n    _kiara_model_id: str = \"onboarding.file.from.local_file\"\n\n    @classmethod\n    def accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n        if os.path.isfile(os.path.abspath(uri)):\n            return True, \"local file exists and is file\"\n        else:\n            return False, \"local file does not exist or is not a file\"\n\n    @classmethod\n    def accepts_bundle_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n        if os.path.isdir(os.path.abspath(uri)):\n            return True, \"local folder exists and is folder\"\n        else:\n            return False, \"local folder does not exist or is not a folder\"\n\n    def retrieve(\n        self, uri: str, file_name: Union[None, str], attach_metadata: bool\n    ) -&gt; KiaraFile:\n\n        if not os.path.exists(os.path.abspath(uri)):\n            raise KiaraException(\n                f\"Can't create file from path '{uri}': path does not exist.\"\n            )\n        if not os.path.isfile(os.path.abspath(uri)):\n            raise KiaraException(\n                f\"Can't create file from path '{uri}': path is not a file.\"\n            )\n\n        return KiaraFile.load_file(uri)\n\n    def retrieve_bundle(\n        self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n    ) -&gt; KiaraFileBundle:\n\n        if not os.path.exists(os.path.abspath(uri)):\n            raise KiaraException(\n                f\"Can't create file from path '{uri}': path does not exist.\"\n            )\n        if not os.path.isdir(os.path.abspath(uri)):\n            raise KiaraException(\n                f\"Can't create file from path '{uri}': path is not a directory.\"\n            )\n\n        return KiaraFileBundle.import_folder(source=uri, import_config=import_config)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromLocalModel-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromLocalModel.accepts_uri","title":"<code>accepts_uri(uri: str) -&gt; Tuple[bool, str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@classmethod\ndef accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n    if os.path.isfile(os.path.abspath(uri)):\n        return True, \"local file exists and is file\"\n    else:\n        return False, \"local file does not exist or is not a file\"\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromLocalModel.accepts_bundle_uri","title":"<code>accepts_bundle_uri(uri: str) -&gt; Tuple[bool, str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@classmethod\ndef accepts_bundle_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n    if os.path.isdir(os.path.abspath(uri)):\n        return True, \"local folder exists and is folder\"\n    else:\n        return False, \"local folder does not exist or is not a folder\"\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromLocalModel.retrieve","title":"<code>retrieve(uri: str, file_name: Union[None, str], attach_metadata: bool) -&gt; KiaraFile</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>def retrieve(\n    self, uri: str, file_name: Union[None, str], attach_metadata: bool\n) -&gt; KiaraFile:\n\n    if not os.path.exists(os.path.abspath(uri)):\n        raise KiaraException(\n            f\"Can't create file from path '{uri}': path does not exist.\"\n        )\n    if not os.path.isfile(os.path.abspath(uri)):\n        raise KiaraException(\n            f\"Can't create file from path '{uri}': path is not a file.\"\n        )\n\n    return KiaraFile.load_file(uri)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromLocalModel.retrieve_bundle","title":"<code>retrieve_bundle(uri: str, import_config: FolderImportConfig, attach_metadata: bool) -&gt; KiaraFileBundle</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>def retrieve_bundle(\n    self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n) -&gt; KiaraFileBundle:\n\n    if not os.path.exists(os.path.abspath(uri)):\n        raise KiaraException(\n            f\"Can't create file from path '{uri}': path does not exist.\"\n        )\n    if not os.path.isdir(os.path.abspath(uri)):\n        raise KiaraException(\n            f\"Can't create file from path '{uri}': path is not a directory.\"\n        )\n\n    return KiaraFileBundle.import_folder(source=uri, import_config=import_config)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromRemoteModel","title":"<code>FileFromRemoteModel</code>","text":"<p>         Bases: <code>OnboardDataModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>class FileFromRemoteModel(OnboardDataModel):\n\n    _kiara_model_id: str = \"onboarding.file.from.url\"\n\n    @classmethod\n    def accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n        accepted_protocols = [\"http\", \"https\"]\n        for protocol in accepted_protocols:\n            if uri.startswith(f\"{protocol}://\"):\n                return True, \"url is valid (starts with http or https)\"\n\n        return False, \"url is not valid (does not start with http or https)\"\n\n    def retrieve(\n        self, uri: str, file_name: Union[None, str], attach_metadata: bool\n    ) -&gt; KiaraFile:\n        from kiara_plugin.onboarding.utils.download import download_file\n\n        result_file: KiaraFile = download_file(  # type: ignore\n            url=uri, file_name=file_name, attach_metadata=attach_metadata\n        )\n        return result_file\n\n    def retrieve_bundle(\n        self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n    ) -&gt; KiaraFileBundle:\n        from kiara_plugin.onboarding.utils.download import download_file_bundle\n\n        result_bundle = download_file_bundle(\n            url=uri, import_config=import_config, attach_metadata=attach_metadata\n        )\n        return result_bundle\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromRemoteModel-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromRemoteModel.accepts_uri","title":"<code>accepts_uri(uri: str) -&gt; Tuple[bool, str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@classmethod\ndef accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n    accepted_protocols = [\"http\", \"https\"]\n    for protocol in accepted_protocols:\n        if uri.startswith(f\"{protocol}://\"):\n            return True, \"url is valid (starts with http or https)\"\n\n    return False, \"url is not valid (does not start with http or https)\"\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromRemoteModel.retrieve","title":"<code>retrieve(uri: str, file_name: Union[None, str], attach_metadata: bool) -&gt; KiaraFile</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>def retrieve(\n    self, uri: str, file_name: Union[None, str], attach_metadata: bool\n) -&gt; KiaraFile:\n    from kiara_plugin.onboarding.utils.download import download_file\n\n    result_file: KiaraFile = download_file(  # type: ignore\n        url=uri, file_name=file_name, attach_metadata=attach_metadata\n    )\n    return result_file\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromRemoteModel.retrieve_bundle","title":"<code>retrieve_bundle(uri: str, import_config: FolderImportConfig, attach_metadata: bool) -&gt; KiaraFileBundle</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>def retrieve_bundle(\n    self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n) -&gt; KiaraFileBundle:\n    from kiara_plugin.onboarding.utils.download import download_file_bundle\n\n    result_bundle = download_file_bundle(\n        url=uri, import_config=import_config, attach_metadata=attach_metadata\n    )\n    return result_bundle\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromZenodoModel","title":"<code>FileFromZenodoModel</code>","text":"<p>         Bases: <code>OnboardDataModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>class FileFromZenodoModel(OnboardDataModel):\n\n    _kiara_model_id: str = \"onboarding.file.from.zenodo\"\n\n    @classmethod\n    def accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n        if uri.startswith(\"zenodo:\"):\n            return True, \"url is valid (follows format 'zenodo:&lt;doi&gt;')\"\n\n        elif \"/zenodo.\" in uri:\n            return True, \"url is valid (contains '/zenodo.')\"\n\n        return False, \"url is not valid (does not follow format 'zenodo:&lt;doi&gt;')\"\n\n    def retrieve(\n        self, uri: str, file_name: Union[None, str], attach_metadata: bool\n    ) -&gt; KiaraFile:\n\n        import pyzenodo3\n\n        from kiara_plugin.onboarding.utils.download import download_file\n\n        if uri.startswith(\"zenodo:\"):\n            doi = uri[len(\"zenodo:\") :]\n        elif \"/zenodo.\" in uri:\n            doi = uri\n\n        tokens = doi.split(\"/zenodo.\")\n        if len(tokens) != 2:\n            raise KiaraException(\n                msg=f\"Can't parse Zenodo DOI from URI for single file download: {doi}\"\n            )\n\n        path_components = tokens[1].split(\"/\", maxsplit=1)\n        if len(path_components) != 2:\n            raise KiaraException(\n                msg=f\"Can't parse Zenodo DOI from URI for single file download: {doi}\"\n            )\n\n        file_path = path_components[1]\n        _doi = f\"{tokens[0]}/zenodo.{path_components[0]}\"\n\n        zen = pyzenodo3.Zenodo()\n        record = zen.find_record_by_doi(_doi)\n\n        match = None\n        for _available_file in record.data[\"files\"]:\n            if file_path == _available_file[\"key\"]:\n                match = _available_file\n                break\n\n        if not match:\n            msg = \"Available files:\\n\"\n            for key in record.data[\"files\"]:\n                msg += f\"  - {key['key']}\\n\"\n            raise KiaraException(\n                msg=f\"Can't find file '{file_path}' in Zenodo record. {msg}\"\n            )\n\n        url = match[\"links\"][\"self\"]\n        checksum = match[\"checksum\"][4:]\n\n        file_name = file_path.split(\"/\")[-1]\n\n        file_model: KiaraFile\n        file_model, md5_digest = download_file(  # type: ignore\n            url=url,\n            target=None,\n            file_name=file_name,\n            attach_metadata=attach_metadata,\n            return_md5_hash=True,\n        )\n\n        if checksum != md5_digest:\n            raise KiaraException(\n                msg=f\"Can't download file '{file_name}', invalid checksum: {checksum} != {md5_digest}\"\n            )\n\n        if attach_metadata:\n            file_model.metadata[\"zenodo_record_data\"] = record.data\n\n        return file_model\n\n    def retrieve_bundle(\n        self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n    ) -&gt; KiaraFileBundle:\n\n        import shutil\n\n        import pyzenodo3\n\n        from kiara_plugin.onboarding.utils.download import download_file\n\n        if uri.startswith(\"zenodo:\"):\n            doi = uri[len(\"zenodo:\") :]\n        elif \"/zenodo.\" in uri:\n            doi = uri\n\n        tokens = doi.split(\"/zenodo.\")\n        if len(tokens) != 2:\n            raise KiaraException(\n                msg=f\"Can't parse Zenodo DOI from URI for single file download: {doi}\"\n            )\n\n        path_components = tokens[1].split(\"/\", maxsplit=1)\n\n        if len(path_components) == 2:\n            zid = path_components[0]\n            file_path = path_components[1]\n        else:\n            zid = path_components[0]\n            file_path = None\n\n        _doi = f\"{tokens[0]}/zenodo.{zid}\"\n\n        if not file_path:\n\n            zen = pyzenodo3.Zenodo()\n\n            record = zen.find_record_by_doi(_doi)\n\n            path = KiaraFileBundle.create_tmp_dir()\n            shutil.rmtree(path, ignore_errors=True)\n            path.mkdir()\n\n            for file_data in record.data[\"files\"]:\n                url = file_data[\"links\"][\"self\"]\n                file_name = file_data[\"key\"]\n                checksum = file_data[\"checksum\"][4:]\n\n                target = os.path.join(path, file_name)\n                file_model: KiaraFile\n                file_model, md5_digest = download_file(  # type: ignore\n                    url=url,\n                    target=target,\n                    file_name=file_name,\n                    attach_metadata=attach_metadata,\n                    return_md5_hash=True,\n                )\n\n                if checksum != md5_digest:\n                    raise KiaraException(\n                        msg=f\"Can't download file '{file_name}', invalid checksum: {checksum} != {md5_digest}\"\n                    )\n\n            bundle = KiaraFileBundle.import_folder(path.as_posix())\n            if attach_metadata:\n                bundle.metadata[\"zenodo_record_data\"] = record.data\n\n        else:\n\n            zen = pyzenodo3.Zenodo()\n            record = zen.find_record_by_doi(_doi)\n\n            match = None\n            for _available_file in record.data[\"files\"]:\n                if file_path == _available_file[\"key\"]:\n                    match = _available_file\n                    break\n\n            if not match:\n                msg = \"Available files:\\n\"\n                for key in record.data[\"files\"]:\n                    msg += f\"  - {key['key']}\\n\"\n                raise KiaraException(\n                    msg=f\"Can't find file '{file_path}' in Zenodo record. {msg}\"\n                )\n\n            url = match[\"links\"][\"self\"]\n            checksum = match[\"checksum\"][4:]\n\n            file_name = file_path.split(\"/\")[-1]\n\n            file_model, md5_digest = download_file(  # type: ignore\n                url=url,\n                target=None,\n                file_name=file_name,\n                attach_metadata=attach_metadata,\n                return_md5_hash=True,\n            )\n\n            if checksum != md5_digest:\n                raise KiaraException(\n                    msg=f\"Can't download file '{file_name}', invalid checksum: {checksum} != {md5_digest}\"\n                )\n\n            bundle = KiaraFileBundle.from_archive_file(\n                archive_file=file_model, import_config=import_config\n            )\n            if attach_metadata:\n                bundle.metadata[\"zenodo_record_data\"] = record.data\n\n        return bundle\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromZenodoModel-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromZenodoModel.accepts_uri","title":"<code>accepts_uri(uri: str) -&gt; Tuple[bool, str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@classmethod\ndef accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n    if uri.startswith(\"zenodo:\"):\n        return True, \"url is valid (follows format 'zenodo:&lt;doi&gt;')\"\n\n    elif \"/zenodo.\" in uri:\n        return True, \"url is valid (contains '/zenodo.')\"\n\n    return False, \"url is not valid (does not follow format 'zenodo:&lt;doi&gt;')\"\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromZenodoModel.retrieve","title":"<code>retrieve(uri: str, file_name: Union[None, str], attach_metadata: bool) -&gt; KiaraFile</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>def retrieve(\n    self, uri: str, file_name: Union[None, str], attach_metadata: bool\n) -&gt; KiaraFile:\n\n    import pyzenodo3\n\n    from kiara_plugin.onboarding.utils.download import download_file\n\n    if uri.startswith(\"zenodo:\"):\n        doi = uri[len(\"zenodo:\") :]\n    elif \"/zenodo.\" in uri:\n        doi = uri\n\n    tokens = doi.split(\"/zenodo.\")\n    if len(tokens) != 2:\n        raise KiaraException(\n            msg=f\"Can't parse Zenodo DOI from URI for single file download: {doi}\"\n        )\n\n    path_components = tokens[1].split(\"/\", maxsplit=1)\n    if len(path_components) != 2:\n        raise KiaraException(\n            msg=f\"Can't parse Zenodo DOI from URI for single file download: {doi}\"\n        )\n\n    file_path = path_components[1]\n    _doi = f\"{tokens[0]}/zenodo.{path_components[0]}\"\n\n    zen = pyzenodo3.Zenodo()\n    record = zen.find_record_by_doi(_doi)\n\n    match = None\n    for _available_file in record.data[\"files\"]:\n        if file_path == _available_file[\"key\"]:\n            match = _available_file\n            break\n\n    if not match:\n        msg = \"Available files:\\n\"\n        for key in record.data[\"files\"]:\n            msg += f\"  - {key['key']}\\n\"\n        raise KiaraException(\n            msg=f\"Can't find file '{file_path}' in Zenodo record. {msg}\"\n        )\n\n    url = match[\"links\"][\"self\"]\n    checksum = match[\"checksum\"][4:]\n\n    file_name = file_path.split(\"/\")[-1]\n\n    file_model: KiaraFile\n    file_model, md5_digest = download_file(  # type: ignore\n        url=url,\n        target=None,\n        file_name=file_name,\n        attach_metadata=attach_metadata,\n        return_md5_hash=True,\n    )\n\n    if checksum != md5_digest:\n        raise KiaraException(\n            msg=f\"Can't download file '{file_name}', invalid checksum: {checksum} != {md5_digest}\"\n        )\n\n    if attach_metadata:\n        file_model.metadata[\"zenodo_record_data\"] = record.data\n\n    return file_model\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromZenodoModel.retrieve_bundle","title":"<code>retrieve_bundle(uri: str, import_config: FolderImportConfig, attach_metadata: bool) -&gt; KiaraFileBundle</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>def retrieve_bundle(\n    self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n) -&gt; KiaraFileBundle:\n\n    import shutil\n\n    import pyzenodo3\n\n    from kiara_plugin.onboarding.utils.download import download_file\n\n    if uri.startswith(\"zenodo:\"):\n        doi = uri[len(\"zenodo:\") :]\n    elif \"/zenodo.\" in uri:\n        doi = uri\n\n    tokens = doi.split(\"/zenodo.\")\n    if len(tokens) != 2:\n        raise KiaraException(\n            msg=f\"Can't parse Zenodo DOI from URI for single file download: {doi}\"\n        )\n\n    path_components = tokens[1].split(\"/\", maxsplit=1)\n\n    if len(path_components) == 2:\n        zid = path_components[0]\n        file_path = path_components[1]\n    else:\n        zid = path_components[0]\n        file_path = None\n\n    _doi = f\"{tokens[0]}/zenodo.{zid}\"\n\n    if not file_path:\n\n        zen = pyzenodo3.Zenodo()\n\n        record = zen.find_record_by_doi(_doi)\n\n        path = KiaraFileBundle.create_tmp_dir()\n        shutil.rmtree(path, ignore_errors=True)\n        path.mkdir()\n\n        for file_data in record.data[\"files\"]:\n            url = file_data[\"links\"][\"self\"]\n            file_name = file_data[\"key\"]\n            checksum = file_data[\"checksum\"][4:]\n\n            target = os.path.join(path, file_name)\n            file_model: KiaraFile\n            file_model, md5_digest = download_file(  # type: ignore\n                url=url,\n                target=target,\n                file_name=file_name,\n                attach_metadata=attach_metadata,\n                return_md5_hash=True,\n            )\n\n            if checksum != md5_digest:\n                raise KiaraException(\n                    msg=f\"Can't download file '{file_name}', invalid checksum: {checksum} != {md5_digest}\"\n                )\n\n        bundle = KiaraFileBundle.import_folder(path.as_posix())\n        if attach_metadata:\n            bundle.metadata[\"zenodo_record_data\"] = record.data\n\n    else:\n\n        zen = pyzenodo3.Zenodo()\n        record = zen.find_record_by_doi(_doi)\n\n        match = None\n        for _available_file in record.data[\"files\"]:\n            if file_path == _available_file[\"key\"]:\n                match = _available_file\n                break\n\n        if not match:\n            msg = \"Available files:\\n\"\n            for key in record.data[\"files\"]:\n                msg += f\"  - {key['key']}\\n\"\n            raise KiaraException(\n                msg=f\"Can't find file '{file_path}' in Zenodo record. {msg}\"\n            )\n\n        url = match[\"links\"][\"self\"]\n        checksum = match[\"checksum\"][4:]\n\n        file_name = file_path.split(\"/\")[-1]\n\n        file_model, md5_digest = download_file(  # type: ignore\n            url=url,\n            target=None,\n            file_name=file_name,\n            attach_metadata=attach_metadata,\n            return_md5_hash=True,\n        )\n\n        if checksum != md5_digest:\n            raise KiaraException(\n                msg=f\"Can't download file '{file_name}', invalid checksum: {checksum} != {md5_digest}\"\n            )\n\n        bundle = KiaraFileBundle.from_archive_file(\n            archive_file=file_model, import_config=import_config\n        )\n        if attach_metadata:\n            bundle.metadata[\"zenodo_record_data\"] = record.data\n\n    return bundle\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromZoteroModel","title":"<code>FileFromZoteroModel</code>","text":"<p>         Bases: <code>OnboardDataModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>class FileFromZoteroModel(OnboardDataModel):\n\n    _kiara_model_id = \"onboarding.file.from.zotero\"\n\n    @classmethod\n    def accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n        if uri.startswith(\"zotero:\"):\n            return True, \"uri is a zotero uri\"\n        else:\n            return False, \"uri is not a zotero uri, must start with 'zotero:'\"\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromZoteroModel-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromZoteroModel.accepts_uri","title":"<code>accepts_uri(uri: str) -&gt; Tuple[bool, str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@classmethod\ndef accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n    if uri.startswith(\"zotero:\"):\n        return True, \"uri is a zotero uri\"\n    else:\n        return False, \"uri is not a zotero uri, must start with 'zotero:'\"\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromGithubModel","title":"<code>FileFromGithubModel</code>","text":"<p>         Bases: <code>OnboardDataModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>class FileFromGithubModel(OnboardDataModel):\n\n    _kiara_model_id: str = \"onboarding.file.from.github\"\n\n    @classmethod\n    def accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n        if uri.startswith(\"gh:\") or uri.startswith(\"github:\"):\n            return True, \"uri is a github uri\"\n\n        return False, \"uri is not a github uri, must start with 'gh:' or 'github:'\"\n\n    def retrieve(\n        self, uri: str, file_name: Union[None, str], attach_metadata: bool\n    ) -&gt; KiaraFile:\n        from kiara_plugin.onboarding.utils.download import download_file\n\n        tokens = uri.split(\":\")[1].split(\"/\", maxsplit=3)\n        if len(tokens) != 4:\n            raise KiaraException(\n                msg=f\"Can't parse github uri '{uri}' for single file download. Required format: 'gh:&lt;user&gt;/&lt;repo&gt;/&lt;branch_or_tag&gt;/&lt;path&gt;'\"\n            )\n\n        url = f\"https://raw.githubusercontent.com/{tokens[0]}/{tokens[1]}/{tokens[2]}/{tokens[3]}\"\n\n        result_file: KiaraFile = download_file(  # type: ignore\n            url=url, attach_metadata=attach_metadata\n        )\n        return result_file\n\n    def retrieve_bundle(\n        self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n    ) -&gt; KiaraFileBundle:\n\n        from kiara_plugin.onboarding.utils.download import download_file\n\n        tokens = uri.split(\":\")[1].split(\"/\", maxsplit=3)\n        if len(tokens) == 3:\n            sub_path = None\n        elif len(tokens) != 4:\n            raise KiaraException(\n                msg=f\"Can't parse github uri '{uri}' for single file download. Required format: 'gh:&lt;user&gt;/&lt;repo&gt;/&lt;branch_or_tag&gt;/&lt;path&gt;'\"\n            )\n        else:\n            sub_path = tokens[3]\n\n        url = f\"https://github.com/{tokens[0]}/{tokens[1]}/archive/refs/heads/{tokens[2]}.zip\"\n        file_name = f\"{tokens[1]}-{tokens[2]}.zip\"\n\n        archive_zip: KiaraFile\n        archive_zip = download_file(  # type: ignore\n            url=url,\n            attach_metadata=attach_metadata,\n            file_name=file_name,\n            return_md5_hash=False,\n        )\n\n        base_sub_path = f\"{tokens[1]}-{tokens[2]}\"\n\n        if sub_path:\n            if import_config.sub_path:\n                new_sub_path = \"/\".join([base_sub_path, sub_path, import_config.sub_path])  # type: ignore\n            else:\n                new_sub_path = \"/\".join([base_sub_path, sub_path])\n        elif import_config.sub_path:\n            new_sub_path = \"/\".join([base_sub_path, import_config.sub_path])\n        else:\n            new_sub_path = base_sub_path\n\n        import_config_new = import_config.copy(update={\"sub_path\": new_sub_path})\n\n        result_bundle = KiaraFileBundle.from_archive_file(\n            archive_file=archive_zip, import_config=import_config_new\n        )\n\n        return result_bundle\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromGithubModel-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromGithubModel.accepts_uri","title":"<code>accepts_uri(uri: str) -&gt; Tuple[bool, str]</code>  <code>classmethod</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>@classmethod\ndef accepts_uri(cls, uri: str) -&gt; Tuple[bool, str]:\n\n    if uri.startswith(\"gh:\") or uri.startswith(\"github:\"):\n        return True, \"uri is a github uri\"\n\n    return False, \"uri is not a github uri, must start with 'gh:' or 'github:'\"\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromGithubModel.retrieve","title":"<code>retrieve(uri: str, file_name: Union[None, str], attach_metadata: bool) -&gt; KiaraFile</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>def retrieve(\n    self, uri: str, file_name: Union[None, str], attach_metadata: bool\n) -&gt; KiaraFile:\n    from kiara_plugin.onboarding.utils.download import download_file\n\n    tokens = uri.split(\":\")[1].split(\"/\", maxsplit=3)\n    if len(tokens) != 4:\n        raise KiaraException(\n            msg=f\"Can't parse github uri '{uri}' for single file download. Required format: 'gh:&lt;user&gt;/&lt;repo&gt;/&lt;branch_or_tag&gt;/&lt;path&gt;'\"\n        )\n\n    url = f\"https://raw.githubusercontent.com/{tokens[0]}/{tokens[1]}/{tokens[2]}/{tokens[3]}\"\n\n    result_file: KiaraFile = download_file(  # type: ignore\n        url=url, attach_metadata=attach_metadata\n    )\n    return result_file\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/models/__init__/#kiara_plugin.onboarding.models.FileFromGithubModel.retrieve_bundle","title":"<code>retrieve_bundle(uri: str, import_config: FolderImportConfig, attach_metadata: bool) -&gt; KiaraFileBundle</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/models/__init__.py</code> <pre><code>def retrieve_bundle(\n    self, uri: str, import_config: FolderImportConfig, attach_metadata: bool\n) -&gt; KiaraFileBundle:\n\n    from kiara_plugin.onboarding.utils.download import download_file\n\n    tokens = uri.split(\":\")[1].split(\"/\", maxsplit=3)\n    if len(tokens) == 3:\n        sub_path = None\n    elif len(tokens) != 4:\n        raise KiaraException(\n            msg=f\"Can't parse github uri '{uri}' for single file download. Required format: 'gh:&lt;user&gt;/&lt;repo&gt;/&lt;branch_or_tag&gt;/&lt;path&gt;'\"\n        )\n    else:\n        sub_path = tokens[3]\n\n    url = f\"https://github.com/{tokens[0]}/{tokens[1]}/archive/refs/heads/{tokens[2]}.zip\"\n    file_name = f\"{tokens[1]}-{tokens[2]}.zip\"\n\n    archive_zip: KiaraFile\n    archive_zip = download_file(  # type: ignore\n        url=url,\n        attach_metadata=attach_metadata,\n        file_name=file_name,\n        return_md5_hash=False,\n    )\n\n    base_sub_path = f\"{tokens[1]}-{tokens[2]}\"\n\n    if sub_path:\n        if import_config.sub_path:\n            new_sub_path = \"/\".join([base_sub_path, sub_path, import_config.sub_path])  # type: ignore\n        else:\n            new_sub_path = \"/\".join([base_sub_path, sub_path])\n    elif import_config.sub_path:\n        new_sub_path = \"/\".join([base_sub_path, import_config.sub_path])\n    else:\n        new_sub_path = base_sub_path\n\n    import_config_new = import_config.copy(update={\"sub_path\": new_sub_path})\n\n    result_bundle = KiaraFileBundle.from_archive_file(\n        archive_file=archive_zip, import_config=import_config_new\n    )\n\n    return result_bundle\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/","title":"modules","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.ONBOARDING_MODEL_NAME_PREFIX","title":"<code>ONBOARDING_MODEL_NAME_PREFIX = 'onboarding.file.from.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileConfig","title":"<code>OnboardFileConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>class OnboardFileConfig(KiaraModuleConfig):\n\n    onboard_type: Union[None, str] = Field(\n        description=\"The name of the type of onboarding.\", default=None\n    )\n    attach_metadata: Union[bool, None] = Field(\n        description=\"Whether to attach metadata.\", default=None\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileConfig.onboard_type","title":"<code>onboard_type: Union[None, str] = Field(description='The name of the type of onboarding.', default=None)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileConfig.attach_metadata","title":"<code>attach_metadata: Union[bool, None] = Field(description='Whether to attach metadata.', default=None)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileModule","title":"<code>OnboardFileModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>A generic module that imports a file from one of several possible sources.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>class OnboardFileModule(KiaraModule):\n\"\"\"A generic module that imports a file from one of several possible sources.\"\"\"\n\n    _module_type_name = \"import.file\"\n    _config_cls = OnboardFileConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        result = {\n            \"source\": {\n                \"type\": \"string\",\n                \"doc\": \"The source uri of the file to be onboarded.\",\n                \"optional\": False,\n            },\n            \"file_name\": {\n                \"type\": \"string\",\n                \"doc\": \"The file name to use for the onboarded file (defaults to source file name if possible).\",\n                \"optional\": True,\n            },\n        }\n\n        if self.get_config_value(\"attach_metadata\") is None:\n            result[\"attach_metadata\"] = {\n                \"type\": \"boolean\",\n                \"doc\": \"Whether to attach onboarding metadata to the result file.\",\n                \"default\": True,\n            }\n\n        onboard_type: Union[str, None] = self.get_config_value(\"onboard_type\")\n        if not onboard_type:\n            onboard_model_cls = None\n        else:\n            onboard_model_cls = get_onboard_model_cls(onboard_type)\n\n        if not onboard_model_cls:\n\n            available = (\n                ModelRegistry.instance()\n                .get_models_of_type(OnboardDataModel)\n                .item_infos.keys()\n            )\n\n            if not available:\n                raise KiaraException(msg=\"No onboard models available. This is a bug.\")\n\n            idx = len(ONBOARDING_MODEL_NAME_PREFIX)\n            allowed = sorted((x[idx:] for x in available))\n\n            result[\"onboard_type\"] = {\n                \"type\": \"string\",\n                \"type_config\": {\"allowed_strings\": allowed},\n                \"doc\": \"The type of onboarding to use. Allowed: {}\".format(\n                    \", \".join(allowed)\n                ),\n                \"optional\": True,\n            }\n        elif onboard_model_cls.get_config_fields():\n            result = {\n                \"onboard_config\": {\n                    \"type\": \"kiara_model\",\n                    \"type_config\": {\n                        \"kiara_model_id\": self.get_config_value(\"onboard_type\"),\n                    },\n                }\n            }\n\n        return result\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        result = {\"file\": {\"type\": \"file\", \"doc\": \"The file that was onboarded.\"}}\n        return result\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        onboard_type = self.get_config_value(\"onboard_type\")\n\n        source: str = inputs.get_value_data(\"source\")\n        file_name: Union[str, None] = inputs.get_value_data(\"file_name\")\n\n        if not onboard_type:\n\n            user_input_onboard_type = inputs.get_value_data(\"onboard_type\")\n            if user_input_onboard_type:\n                onboard_type = (\n                    f\"{ONBOARDING_MODEL_NAME_PREFIX}{user_input_onboard_type}\"\n                )\n\n        attach_metadata = self.get_config_value(\"attach_metadata\")\n        if attach_metadata is None:\n            attach_metadata = inputs.get_value_data(\"attach_metadata\")\n\n        data = onboard_file(\n            source=source,\n            file_name=file_name,\n            onboard_type=onboard_type,\n            attach_metadata=attach_metadata,\n        )\n\n        outputs.set_value(\"file\", data)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileModule._config_cls","title":"<code>_config_cls = OnboardFileConfig</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    result = {\n        \"source\": {\n            \"type\": \"string\",\n            \"doc\": \"The source uri of the file to be onboarded.\",\n            \"optional\": False,\n        },\n        \"file_name\": {\n            \"type\": \"string\",\n            \"doc\": \"The file name to use for the onboarded file (defaults to source file name if possible).\",\n            \"optional\": True,\n        },\n    }\n\n    if self.get_config_value(\"attach_metadata\") is None:\n        result[\"attach_metadata\"] = {\n            \"type\": \"boolean\",\n            \"doc\": \"Whether to attach onboarding metadata to the result file.\",\n            \"default\": True,\n        }\n\n    onboard_type: Union[str, None] = self.get_config_value(\"onboard_type\")\n    if not onboard_type:\n        onboard_model_cls = None\n    else:\n        onboard_model_cls = get_onboard_model_cls(onboard_type)\n\n    if not onboard_model_cls:\n\n        available = (\n            ModelRegistry.instance()\n            .get_models_of_type(OnboardDataModel)\n            .item_infos.keys()\n        )\n\n        if not available:\n            raise KiaraException(msg=\"No onboard models available. This is a bug.\")\n\n        idx = len(ONBOARDING_MODEL_NAME_PREFIX)\n        allowed = sorted((x[idx:] for x in available))\n\n        result[\"onboard_type\"] = {\n            \"type\": \"string\",\n            \"type_config\": {\"allowed_strings\": allowed},\n            \"doc\": \"The type of onboarding to use. Allowed: {}\".format(\n                \", \".join(allowed)\n            ),\n            \"optional\": True,\n        }\n    elif onboard_model_cls.get_config_fields():\n        result = {\n            \"onboard_config\": {\n                \"type\": \"kiara_model\",\n                \"type_config\": {\n                    \"kiara_model_id\": self.get_config_value(\"onboard_type\"),\n                },\n            }\n        }\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    result = {\"file\": {\"type\": \"file\", \"doc\": \"The file that was onboarded.\"}}\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    onboard_type = self.get_config_value(\"onboard_type\")\n\n    source: str = inputs.get_value_data(\"source\")\n    file_name: Union[str, None] = inputs.get_value_data(\"file_name\")\n\n    if not onboard_type:\n\n        user_input_onboard_type = inputs.get_value_data(\"onboard_type\")\n        if user_input_onboard_type:\n            onboard_type = (\n                f\"{ONBOARDING_MODEL_NAME_PREFIX}{user_input_onboard_type}\"\n            )\n\n    attach_metadata = self.get_config_value(\"attach_metadata\")\n    if attach_metadata is None:\n        attach_metadata = inputs.get_value_data(\"attach_metadata\")\n\n    data = onboard_file(\n        source=source,\n        file_name=file_name,\n        onboard_type=onboard_type,\n        attach_metadata=attach_metadata,\n    )\n\n    outputs.set_value(\"file\", data)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleConfig","title":"<code>OnboardFileBundleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>class OnboardFileBundleConfig(KiaraModuleConfig):\n\n    onboard_type: Union[None, str] = Field(\n        description=\"The name of the type of onboarding.\", default=None\n    )\n    attach_metadata: Union[bool, None] = Field(\n        description=\"Whether to attach onboarding metadata.\", default=None\n    )\n    sub_path: Union[None, str] = Field(description=\"The sub path to use.\", default=None)\n    include_files: Union[None, List[str]] = Field(\n        description=\"File types to include.\", default=None\n    )\n    exclude_files: Union[None, List[str]] = Field(\n        description=\"File types to include.\", default=None\n    )\n    exclude_dirs: Union[None, List[str]] = Field(\n        description=\"Exclude directories that end with one of those tokens.\",\n        default=None,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleConfig.onboard_type","title":"<code>onboard_type: Union[None, str] = Field(description='The name of the type of onboarding.', default=None)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleConfig.attach_metadata","title":"<code>attach_metadata: Union[bool, None] = Field(description='Whether to attach onboarding metadata.', default=None)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleConfig.sub_path","title":"<code>sub_path: Union[None, str] = Field(description='The sub path to use.', default=None)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleConfig.include_files","title":"<code>include_files: Union[None, List[str]] = Field(description='File types to include.', default=None)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleConfig.exclude_files","title":"<code>exclude_files: Union[None, List[str]] = Field(description='File types to include.', default=None)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleConfig.exclude_dirs","title":"<code>exclude_dirs: Union[None, List[str]] = Field(description='Exclude directories that end with one of those tokens.', default=None)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleModule","title":"<code>OnboardFileBundleModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>A generic module that imports a file from one of several possible sources.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>class OnboardFileBundleModule(KiaraModule):\n\"\"\"A generic module that imports a file from one of several possible sources.\"\"\"\n\n    _module_type_name = \"import.file_bundle\"\n    _config_cls = OnboardFileBundleConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        result = {\n            \"source\": {\n                \"type\": \"string\",\n                \"doc\": \"The source uri of the file to be onboarded.\",\n                \"optional\": False,\n            }\n        }\n\n        if self.get_config_value(\"attach_metadata\") is None:\n            result[\"attach_metadata\"] = {\n                \"type\": \"boolean\",\n                \"doc\": \"Whether to attach onboarding metadata.\",\n                \"default\": True,\n            }\n        if self.get_config_value(\"sub_path\") is None:\n            result[\"sub_path\"] = {\n                \"type\": \"string\",\n                \"doc\": \"The sub path to use. If not specified, the root of the source folder will be used.\",\n                \"optional\": True,\n            }\n        if self.get_config_value(\"include_files\") is None:\n            result[\"include_files\"] = {\n                \"type\": \"list\",\n                \"doc\": \"Include files that end with one of those tokens. If not specified, all file extensions are included.\",\n                \"optional\": True,\n            }\n\n        if self.get_config_value(\"exclude_files\") is None:\n            result[\"exclude_files\"] = {\n                \"type\": \"list\",\n                \"doc\": \"Exclude files that end with one of those tokens. If not specified, no file extensions are excluded.\",\n                \"optional\": True,\n            }\n        if self.get_config_value(\"exclude_dirs\") is None:\n            result[\"exclude_dirs\"] = {\n                \"type\": \"list\",\n                \"doc\": \"Exclude directories that end with one of those tokens. If not specified, no directories are excluded.\",\n                \"optional\": True,\n            }\n\n        onboard_type: Union[str, None] = self.get_config_value(\"onboard_type\")\n        if not onboard_type:\n            onboard_model_cls = None\n        else:\n            onboard_model_cls = get_onboard_model_cls(onboard_type)\n\n        if not onboard_model_cls:\n\n            available = (\n                ModelRegistry.instance()\n                .get_models_of_type(OnboardDataModel)\n                .item_infos.keys()\n            )\n\n            if not available:\n                raise KiaraException(msg=\"No onboard models available. This is a bug.\")\n\n            idx = len(ONBOARDING_MODEL_NAME_PREFIX)\n            allowed = sorted((x[idx:] for x in available))\n\n            result[\"onboard_type\"] = {\n                \"type\": \"string\",\n                \"type_config\": {\"allowed_strings\": allowed},\n                \"doc\": \"The type of onboarding to use. Allowed: {}\".format(\n                    \", \".join(allowed)\n                ),\n                \"optional\": True,\n            }\n        elif onboard_model_cls.get_config_fields():\n            result = {\n                \"onboard_config\": {\n                    \"type\": \"kiara_model\",\n                    \"type_config\": {\n                        \"kiara_model_id\": self.get_config_value(\"onboard_type\"),\n                    },\n                }\n            }\n\n        return result\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        result = {\n            \"file_bundle\": {\n                \"type\": \"file_bundle\",\n                \"doc\": \"The file_bundle that was onboarded.\",\n            }\n        }\n        return result\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        onboard_type = self.get_config_value(\"onboard_type\")\n        source: str = inputs.get_value_data(\"source\")\n\n        if onboard_type:\n            user_input_onboard_type = inputs.get_value_data(\"onboard_type\")\n            if not user_input_onboard_type:\n                onboard_type = (\n                    f\"{ONBOARDING_MODEL_NAME_PREFIX}{user_input_onboard_type}\"\n                )\n\n        sub_path = self.get_config_value(\"sub_path\")\n        if sub_path is None:\n            sub_path = inputs.get_value_data(\"sub_path\")\n\n        include = self.get_config_value(\"include_files\")\n        if include is None:\n            _include = inputs.get_value_data(\"include_files\")\n            if _include:\n                include = _include.list_data\n        exclude = self.get_config_value(\"exclude_files\")\n        if exclude is None:\n            _exclude = inputs.get_value_data(\"exclude_files\")\n            if _exclude:\n                exclude = _exclude.list_data\n        exclude_dirs = self.get_config_value(\"exclude_dirs\")\n        if exclude_dirs is None:\n            _exclude_dirs = inputs.get_value_data(\"exclude_dirs\")\n            if _exclude_dirs:\n                exclude_dirs = _exclude_dirs.list_data\n\n        import_config_data = {\n            \"sub_path\": sub_path,\n        }\n        if include:\n            import_config_data[\"include_files\"] = include\n        if exclude:\n            import_config_data[\"exclude_files\"] = exclude\n        if exclude_dirs:\n            import_config_data[\"exclude_dirs\"] = exclude_dirs\n\n        import_config = FolderImportConfig(**import_config_data)\n        attach_metadata = self.get_config_value(\"attach_metadata\")\n        if attach_metadata is None:\n            attach_metadata = inputs.get_value_data(\"attach_metadata\")\n\n        imported_bundle = onboard_file_bundle(\n            source=source,\n            import_config=import_config,\n            onboard_type=onboard_type,\n            attach_metadata=attach_metadata,\n        )\n\n        outputs.set_value(\"file_bundle\", imported_bundle)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleModule._config_cls","title":"<code>_config_cls = OnboardFileBundleConfig</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    result = {\n        \"source\": {\n            \"type\": \"string\",\n            \"doc\": \"The source uri of the file to be onboarded.\",\n            \"optional\": False,\n        }\n    }\n\n    if self.get_config_value(\"attach_metadata\") is None:\n        result[\"attach_metadata\"] = {\n            \"type\": \"boolean\",\n            \"doc\": \"Whether to attach onboarding metadata.\",\n            \"default\": True,\n        }\n    if self.get_config_value(\"sub_path\") is None:\n        result[\"sub_path\"] = {\n            \"type\": \"string\",\n            \"doc\": \"The sub path to use. If not specified, the root of the source folder will be used.\",\n            \"optional\": True,\n        }\n    if self.get_config_value(\"include_files\") is None:\n        result[\"include_files\"] = {\n            \"type\": \"list\",\n            \"doc\": \"Include files that end with one of those tokens. If not specified, all file extensions are included.\",\n            \"optional\": True,\n        }\n\n    if self.get_config_value(\"exclude_files\") is None:\n        result[\"exclude_files\"] = {\n            \"type\": \"list\",\n            \"doc\": \"Exclude files that end with one of those tokens. If not specified, no file extensions are excluded.\",\n            \"optional\": True,\n        }\n    if self.get_config_value(\"exclude_dirs\") is None:\n        result[\"exclude_dirs\"] = {\n            \"type\": \"list\",\n            \"doc\": \"Exclude directories that end with one of those tokens. If not specified, no directories are excluded.\",\n            \"optional\": True,\n        }\n\n    onboard_type: Union[str, None] = self.get_config_value(\"onboard_type\")\n    if not onboard_type:\n        onboard_model_cls = None\n    else:\n        onboard_model_cls = get_onboard_model_cls(onboard_type)\n\n    if not onboard_model_cls:\n\n        available = (\n            ModelRegistry.instance()\n            .get_models_of_type(OnboardDataModel)\n            .item_infos.keys()\n        )\n\n        if not available:\n            raise KiaraException(msg=\"No onboard models available. This is a bug.\")\n\n        idx = len(ONBOARDING_MODEL_NAME_PREFIX)\n        allowed = sorted((x[idx:] for x in available))\n\n        result[\"onboard_type\"] = {\n            \"type\": \"string\",\n            \"type_config\": {\"allowed_strings\": allowed},\n            \"doc\": \"The type of onboarding to use. Allowed: {}\".format(\n                \", \".join(allowed)\n            ),\n            \"optional\": True,\n        }\n    elif onboard_model_cls.get_config_fields():\n        result = {\n            \"onboard_config\": {\n                \"type\": \"kiara_model\",\n                \"type_config\": {\n                    \"kiara_model_id\": self.get_config_value(\"onboard_type\"),\n                },\n            }\n        }\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    result = {\n        \"file_bundle\": {\n            \"type\": \"file_bundle\",\n            \"doc\": \"The file_bundle that was onboarded.\",\n        }\n    }\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules.OnboardFileBundleModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/__init__.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    onboard_type = self.get_config_value(\"onboard_type\")\n    source: str = inputs.get_value_data(\"source\")\n\n    if onboard_type:\n        user_input_onboard_type = inputs.get_value_data(\"onboard_type\")\n        if not user_input_onboard_type:\n            onboard_type = (\n                f\"{ONBOARDING_MODEL_NAME_PREFIX}{user_input_onboard_type}\"\n            )\n\n    sub_path = self.get_config_value(\"sub_path\")\n    if sub_path is None:\n        sub_path = inputs.get_value_data(\"sub_path\")\n\n    include = self.get_config_value(\"include_files\")\n    if include is None:\n        _include = inputs.get_value_data(\"include_files\")\n        if _include:\n            include = _include.list_data\n    exclude = self.get_config_value(\"exclude_files\")\n    if exclude is None:\n        _exclude = inputs.get_value_data(\"exclude_files\")\n        if _exclude:\n            exclude = _exclude.list_data\n    exclude_dirs = self.get_config_value(\"exclude_dirs\")\n    if exclude_dirs is None:\n        _exclude_dirs = inputs.get_value_data(\"exclude_dirs\")\n        if _exclude_dirs:\n            exclude_dirs = _exclude_dirs.list_data\n\n    import_config_data = {\n        \"sub_path\": sub_path,\n    }\n    if include:\n        import_config_data[\"include_files\"] = include\n    if exclude:\n        import_config_data[\"exclude_files\"] = exclude\n    if exclude_dirs:\n        import_config_data[\"exclude_dirs\"] = exclude_dirs\n\n    import_config = FolderImportConfig(**import_config_data)\n    attach_metadata = self.get_config_value(\"attach_metadata\")\n    if attach_metadata is None:\n        attach_metadata = inputs.get_value_data(\"attach_metadata\")\n\n    imported_bundle = onboard_file_bundle(\n        source=source,\n        import_config=import_config,\n        onboard_type=onboard_type,\n        attach_metadata=attach_metadata,\n    )\n\n    outputs.set_value(\"file_bundle\", imported_bundle)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/__init__/#kiara_plugin.onboarding.modules-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/","title":"zenodo","text":""},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownloadConfig","title":"<code>ZenodoDownloadConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/zenodo.py</code> <pre><code>class ZenodoDownloadConfig(KiaraModuleConfig):\n\n    metadata_filename: str = Field(\n        description=\"The filename for the zenodo metadata.\", default=\"metadata.json\"\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownloadConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownloadConfig.metadata_filename","title":"<code>metadata_filename: str = Field(description='The filename for the zenodo metadata.', default='metadata.json')</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownload","title":"<code>ZenodoDownload</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Download a dataset from zenodo.org.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/zenodo.py</code> <pre><code>class ZenodoDownload(KiaraModule):\n\"\"\"Download a dataset from zenodo.org.\"\"\"\n\n    _module_type_name = \"onboard.zenodo_record\"\n    _config_cls = ZenodoDownloadConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        metadata_filename = self.get_config_value(\"metadata_filename\")\n        return {\n            \"doi\": {\"type\": \"string\", \"doc\": \"The doi of the record\"},\n            \"include_metadata\": {\n                \"type\": \"boolean\",\n                \"doc\": f\"Whether to write the record metadata to a file '{metadata_filename}' and include it in the resulting file bundle.\",\n                \"default\": True,\n            },\n        }\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\n            \"file_bundle\": {\n                \"type\": \"file_bundle\",\n            }\n        }\n\n    def download_file(self, file_data: Mapping[str, Any], target_path: Path):\n\n        import httpx\n\n        url = file_data[\"links\"][\"self\"]\n        file_name = file_data[\"key\"]\n        checksum = file_data[\"checksum\"][4:]\n\n        target_file = target_path / file_name\n\n        if target_file.exists():\n            raise KiaraProcessingException(\n                f\"Can't download file, target path already exists: {target_path.as_posix()}.\"\n            )\n\n        hash_md5 = hashlib.md5()  # noqa\n\n        with open(target_file, \"ab\") as file2:\n            with httpx.Client() as client:\n                with client.stream(\"GET\", url) as resp:\n                    for chunk in resp.iter_bytes():\n                        hash_md5.update(chunk)\n                        file2.write(chunk)\n\n        if checksum != hash_md5.hexdigest():\n            raise KiaraProcessingException(\n                f\"Can't downloda file '{file_name}', invalid checksum: {checksum} != {hash_md5.hexdigest()}\"\n            )\n\n        return target_file\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        import pyzenodo3\n\n        include_metadata = inputs.get_value_data(\"include_metadata\")\n\n        doi = inputs.get_value_data(\"doi\")\n        zen = pyzenodo3.Zenodo()\n\n        record = zen.find_record_by_doi(doi)\n\n        path = KiaraFileBundle.create_tmp_dir()\n        shutil.rmtree(path, ignore_errors=True)\n        path.mkdir()\n        for file_data in record.data[\"files\"]:\n            self.download_file(file_data, path)\n\n        if include_metadata:\n            metadata_filename = self.get_config_value(\"metadata_filename\")\n            metadata_file = path / metadata_filename\n            metadata_file.write_bytes(orjson.dumps(record.data))\n\n        bundle = KiaraFileBundle.import_folder(path.as_posix())\n        outputs.set_value(\"file_bundle\", bundle)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownload-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownload._config_cls","title":"<code>_config_cls = ZenodoDownloadConfig</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownload-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownload.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/zenodo.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    metadata_filename = self.get_config_value(\"metadata_filename\")\n    return {\n        \"doi\": {\"type\": \"string\", \"doc\": \"The doi of the record\"},\n        \"include_metadata\": {\n            \"type\": \"boolean\",\n            \"doc\": f\"Whether to write the record metadata to a file '{metadata_filename}' and include it in the resulting file bundle.\",\n            \"default\": True,\n        },\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownload.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/zenodo.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\n        \"file_bundle\": {\n            \"type\": \"file_bundle\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownload.download_file","title":"<code>download_file(file_data: Mapping[str, Any], target_path: Path)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/zenodo.py</code> <pre><code>def download_file(self, file_data: Mapping[str, Any], target_path: Path):\n\n    import httpx\n\n    url = file_data[\"links\"][\"self\"]\n    file_name = file_data[\"key\"]\n    checksum = file_data[\"checksum\"][4:]\n\n    target_file = target_path / file_name\n\n    if target_file.exists():\n        raise KiaraProcessingException(\n            f\"Can't download file, target path already exists: {target_path.as_posix()}.\"\n        )\n\n    hash_md5 = hashlib.md5()  # noqa\n\n    with open(target_file, \"ab\") as file2:\n        with httpx.Client() as client:\n            with client.stream(\"GET\", url) as resp:\n                for chunk in resp.iter_bytes():\n                    hash_md5.update(chunk)\n                    file2.write(chunk)\n\n    if checksum != hash_md5.hexdigest():\n        raise KiaraProcessingException(\n            f\"Can't downloda file '{file_name}', invalid checksum: {checksum} != {hash_md5.hexdigest()}\"\n        )\n\n    return target_file\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/zenodo/#kiara_plugin.onboarding.modules.zenodo.ZenodoDownload.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/modules/zenodo.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    import pyzenodo3\n\n    include_metadata = inputs.get_value_data(\"include_metadata\")\n\n    doi = inputs.get_value_data(\"doi\")\n    zen = pyzenodo3.Zenodo()\n\n    record = zen.find_record_by_doi(doi)\n\n    path = KiaraFileBundle.create_tmp_dir()\n    shutil.rmtree(path, ignore_errors=True)\n    path.mkdir()\n    for file_data in record.data[\"files\"]:\n        self.download_file(file_data, path)\n\n    if include_metadata:\n        metadata_filename = self.get_config_value(\"metadata_filename\")\n        metadata_file = path / metadata_filename\n        metadata_file.write_bytes(orjson.dumps(record.data))\n\n    bundle = KiaraFileBundle.import_folder(path.as_posix())\n    outputs.set_value(\"file_bundle\", bundle)\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/modules/files/__init__/","title":"files","text":""},{"location":"reference/kiara_plugin/onboarding/modules/files/import_file/","title":"import_file","text":""},{"location":"reference/kiara_plugin/onboarding/modules/files/import_file_bundle/","title":"import_file_bundle","text":""},{"location":"reference/kiara_plugin/onboarding/pipelines/__init__/","title":"pipelines","text":"<p>Default (empty) module that is used as a base path for pipelines contained in this package.</p>"},{"location":"reference/kiara_plugin/onboarding/utils/__init__/","title":"utils","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/","title":"download","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.DownloadMetadata","title":"<code>DownloadMetadata</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/utils/download.py</code> <pre><code>class DownloadMetadata(BaseModel):\n    url: str = Field(description=\"The url of the download request.\")\n    response_headers: List[Dict[str, str]] = Field(\n        description=\"The response headers of the download request.\"\n    )\n    request_time: str = Field(description=\"The time the request was made.\")\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.DownloadMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.DownloadMetadata.url","title":"<code>url: str = Field(description='The url of the download request.')</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.DownloadMetadata.response_headers","title":"<code>response_headers: List[Dict[str, str]] = Field(description='The response headers of the download request.')</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.DownloadMetadata.request_time","title":"<code>request_time: str = Field(description='The time the request was made.')</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.DownloadBundleMetadata","title":"<code>DownloadBundleMetadata</code>","text":"<p>         Bases: <code>DownloadMetadata</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/utils/download.py</code> <pre><code>class DownloadBundleMetadata(DownloadMetadata):\n    import_config: FolderImportConfig = Field(\n        description=\"The import configuration that was used to import the files from the source bundle.\"\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.DownloadBundleMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.DownloadBundleMetadata.import_config","title":"<code>import_config: FolderImportConfig = Field(description='The import configuration that was used to import the files from the source bundle.')</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.get_onboard_model_cls","title":"<code>get_onboard_model_cls(onboard_type: Union[str, None]) -&gt; Union[None, Type[OnboardDataModel]]</code>  <code>cached</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/utils/download.py</code> <pre><code>@lru_cache()\ndef get_onboard_model_cls(\n    onboard_type: Union[str, None]\n) -&gt; Union[None, Type[OnboardDataModel]]:\n\n    if not onboard_type:\n        return None\n\n    from kiara.registries.models import ModelRegistry\n\n    model_registry = ModelRegistry.instance()\n    model_cls = model_registry.get_model_cls(onboard_type, OnboardDataModel)\n    return model_cls  # type: ignore\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.download_file","title":"<code>download_file(url: str, target: Union[str, None] = None, file_name: Union[str, None] = None, attach_metadata: bool = True, return_md5_hash: bool = False) -&gt; Union[KiaraFile, Tuple[KiaraFile, str]]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/utils/download.py</code> <pre><code>def download_file(\n    url: str,\n    target: Union[str, None] = None,\n    file_name: Union[str, None] = None,\n    attach_metadata: bool = True,\n    return_md5_hash: bool = False,\n) -&gt; Union[KiaraFile, Tuple[KiaraFile, str]]:\n\n    import hashlib\n\n    import httpx\n    import pytz\n\n    if not file_name:\n        # TODO: make this smarter, using content-disposition headers if available\n        file_name = url.split(\"/\")[-1]\n\n    if not target:\n        tmp_file = tempfile.NamedTemporaryFile(delete=False, suffix=file_name)\n\n        def rm_tmp_file():\n            os.unlink(tmp_file.name)\n\n        atexit.register(rm_tmp_file)\n\n        _target = Path(tmp_file.name)\n    else:\n        _target = Path(target)\n        _target.parent.mkdir(parents=True, exist_ok=True)\n\n    if return_md5_hash:\n        hash_md5 = hashlib.md5()  # noqa\n\n    history = []\n    datetime.utcnow().replace(tzinfo=pytz.utc)\n    with open(_target, \"wb\") as f:\n        with httpx.stream(\"GET\", url, follow_redirects=True) as r:\n            if r.status_code &lt; 200 or r.status_code &gt;= 399:\n                raise KiaraException(\n                    f\"Could not download file from {url}: status code {r.status_code}.\"\n                )\n            history.append(dict(r.headers))\n            for h in r.history:\n                history.append(dict(h.headers))\n            for data in r.iter_bytes():\n                if return_md5_hash:\n                    hash_md5.update(data)\n                f.write(data)\n\n    result_file = KiaraFile.load_file(_target.as_posix(), file_name)\n\n    if attach_metadata:\n        metadata = {\n            \"url\": url,\n            \"response_headers\": history,\n            \"request_time\": datetime.utcnow().replace(tzinfo=pytz.utc).isoformat(),\n        }\n        _metadata = DownloadMetadata(**metadata)\n        result_file.metadata[\"download_info\"] = _metadata.dict()\n        result_file.metadata_schemas[\"download_info\"] = DownloadMetadata.schema_json()\n\n    if return_md5_hash:\n        return result_file, hash_md5.hexdigest()\n    else:\n        return result_file\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.download_file_bundle","title":"<code>download_file_bundle(url: str, attach_metadata: bool = True, import_config: Union[FolderImportConfig, None] = None) -&gt; KiaraFileBundle</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/utils/download.py</code> <pre><code>def download_file_bundle(\n    url: str,\n    attach_metadata: bool = True,\n    import_config: Union[FolderImportConfig, None] = None,\n) -&gt; KiaraFileBundle:\n\n    import shutil\n    from datetime import datetime\n    from urllib.parse import urlparse\n\n    import httpx\n    import pytz\n\n    suffix = None\n    try:\n        parsed_url = urlparse(url)\n        _, suffix = os.path.splitext(parsed_url.path)\n    except Exception:\n        pass\n    if not suffix:\n        suffix = \"\"\n\n    tmp_file = tempfile.NamedTemporaryFile(delete=False, suffix=suffix)\n    atexit.register(tmp_file.close)\n\n    history = []\n    datetime.utcnow().replace(tzinfo=pytz.utc)\n    with open(tmp_file.name, \"wb\") as f:\n        with httpx.stream(\"GET\", url, follow_redirects=True) as r:\n            history.append(dict(r.headers))\n            for h in r.history:\n                history.append(dict(h.headers))\n            for data in r.iter_bytes():\n                f.write(data)\n\n    out_dir = tempfile.mkdtemp()\n\n    def del_out_dir():\n        shutil.rmtree(out_dir, ignore_errors=True)\n\n    atexit.register(del_out_dir)\n\n    # error = None\n    # try:\n    #     shutil.unpack_archive(tmp_file.name, out_dir)\n    # except Exception:\n    #     # try patool, maybe we're lucky\n    #     try:\n    #         import patoolib\n    #\n    #         patoolib.extract_archive(tmp_file.name, outdir=out_dir)\n    #     except Exception as e:\n    #         error = e\n    #\n    # if error is not None:\n    #     raise KiaraException(msg=f\"Could not extract archive: {error}.\")\n\n    unpack_archive(tmp_file.name, out_dir)\n    bundle = KiaraFileBundle.import_folder(out_dir, import_config=import_config)\n\n    if import_config is None:\n        ic_dict = {}\n    elif isinstance(import_config, FolderImportConfig):\n        ic_dict = import_config.dict()\n    else:\n        ic_dict = import_config\n    if attach_metadata:\n        metadata = {\n            \"url\": url,\n            \"response_headers\": history,\n            \"request_time\": datetime.utcnow().replace(tzinfo=pytz.utc).isoformat(),\n            \"import_config\": ic_dict,\n        }\n        _metadata = DownloadBundleMetadata(**metadata)\n        bundle.metadata[\"download_info\"] = _metadata.dict()\n        bundle.metadata_schemas[\"download_info\"] = DownloadMetadata.schema_json()\n\n    return bundle\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.find_matching_onboard_models","title":"<code>find_matching_onboard_models(uri: str, for_bundle: bool = False) -&gt; Mapping[Type[OnboardDataModel], Tuple[bool, str]]</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/utils/download.py</code> <pre><code>def find_matching_onboard_models(\n    uri: str, for_bundle: bool = False\n) -&gt; Mapping[Type[OnboardDataModel], Tuple[bool, str]]:\n\n    from kiara.registries.models import ModelRegistry\n\n    model_registry = ModelRegistry.instance()\n    onboard_models = model_registry.get_models_of_type(\n        OnboardDataModel\n    ).item_infos.values()\n\n    result = {}\n    onboard_model: Type[OnboardDataModel]\n    for onboard_model in onboard_models:  # type: ignore\n\n        python_cls: Type[OnboardDataModel] = onboard_model.python_class.get_class()  # type: ignore\n        if for_bundle:\n            result[python_cls] = python_cls.accepts_bundle_uri(uri)\n        else:\n            result[python_cls] = python_cls.accepts_uri(uri)\n\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.onboard_file","title":"<code>onboard_file(source: str, file_name: Union[str, None] = None, onboard_type: Union[str, None] = None, attach_metadata: bool = True) -&gt; KiaraFile</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/utils/download.py</code> <pre><code>def onboard_file(\n    source: str,\n    file_name: Union[str, None] = None,\n    onboard_type: Union[str, None] = None,\n    attach_metadata: bool = True,\n) -&gt; KiaraFile:\n\n    if not onboard_type:\n\n        model_clsses = find_matching_onboard_models(source)\n        matches = [k for k, v in model_clsses.items() if v[0]]\n        if not matches:\n            raise KiaraException(\n                msg=f\"Can't onboard file from '{source}': no onboard models found that accept this source type.\"\n            )\n        elif len(matches) &gt; 1:\n            msg = \"Valid onboarding types for this uri:\\n\\n\"\n            for k, v in model_clsses.items():\n                if not v[0]:\n                    continue\n                msg += f\"  - {k._kiara_model_id}: {v[1]}\\n\"\n            raise KiaraException(\n                msg=f\"Can't onboard file from '{source}': multiple onboard models found that accept this source type.\\n\\n{msg}\"\n            )\n\n        model_cls: Type[OnboardDataModel] = matches[0]\n\n    else:\n\n        model_cls = get_onboard_model_cls(onboard_type=onboard_type)  # type: ignore\n        if not model_cls:\n            raise KiaraException(msg=f\"Can't onboard file from '{source}' using onboard type '{onboard_type}': no onboard model found with this name.\")  # type: ignore\n\n        valid, msg = model_cls.accepts_uri(source)\n        if not valid:\n            raise KiaraException(msg=f\"Can't onboard file from '{source}' using onboard type '{model_cls._kiara_model_id}': {msg}\")  # type: ignore\n\n    if not model_cls.get_config_fields():\n        model = model_cls()\n    else:\n        raise NotImplementedError()\n\n    result = model.retrieve(\n        uri=source, file_name=file_name, attach_metadata=attach_metadata\n    )\n    if not result:\n        raise KiaraException(msg=f\"Can't onboard file from '{source}' using onboard type '{model_cls._kiara_model_id}': no result data retrieved. This is most likely a bug.\")  # type: ignore\n\n    if isinstance(result, str):\n        data = KiaraFile.load_file(result, file_name=file_name)\n    elif not isinstance(result, KiaraFile):\n        raise KiaraException(\n            \"Can't onboard file: onboard model returned data that is not a file. This is most likely a bug.\"\n        )\n    else:\n        data = result\n\n    return data\n</code></pre>"},{"location":"reference/kiara_plugin/onboarding/utils/download/#kiara_plugin.onboarding.utils.download.onboard_file_bundle","title":"<code>onboard_file_bundle(source: str, import_config: Union[FolderImportConfig, None], onboard_type: Union[str, None] = None, attach_metadata: bool = True) -&gt; KiaraFileBundle</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/kiara_plugin/onboarding/utils/download.py</code> <pre><code>def onboard_file_bundle(\n    source: str,\n    import_config: Union[FolderImportConfig, None],\n    onboard_type: Union[str, None] = None,\n    attach_metadata: bool = True,\n) -&gt; KiaraFileBundle:\n\n    if not onboard_type:\n\n        model_clsses = find_matching_onboard_models(uri=source, for_bundle=True)\n        matches = [k for k, v in model_clsses.items() if v[0]]\n        if not matches:\n            raise KiaraException(\n                msg=f\"Can't onboard file from '{source}': no onboard models found that accept this source type.\"\n            )\n        elif len(matches) &gt; 1:\n            msg = \"Valid onboarding types for this uri:\\n\\n\"\n            for k, v in model_clsses.items():\n                if not v[0]:\n                    continue\n                msg += f\"  - {k._kiara_model_id}: {v[1]}\\n\"\n            raise KiaraException(\n                msg=f\"Can't onboard file from '{source}': multiple onboard models found that accept this source type.\\n\\n{msg}\"\n            )\n\n        model_cls: Type[OnboardDataModel] = matches[0]\n\n    else:\n        model_cls = get_onboard_model_cls(onboard_type=onboard_type)  # type: ignore\n        if not model_cls:\n            raise KiaraException(msg=f\"Can't onboard file from '{source}' using onboard type '{onboard_type}': no onboard model found with this name.\")  # type: ignore\n        valid, msg = model_cls.accepts_bundle_uri(source)\n        if not valid:\n            raise KiaraException(msg=f\"Can't onboard file from '{source}' using onboard type '{model_cls._kiara_model_id}': {msg}\")  # type: ignore\n\n    if not model_cls.get_config_fields():\n        model = model_cls()\n    else:\n        raise NotImplementedError()\n\n    if not import_config:\n        import_config = FolderImportConfig()\n\n    try:\n        result: Union[None, KiaraFileBundle] = model.retrieve_bundle(\n            uri=source, import_config=import_config, attach_metadata=attach_metadata\n        )\n\n        if not result:\n            raise KiaraException(msg=f\"Can't onboard file bundle from '{source}' using onboard type '{model_cls._kiara_model_id}': no result data retrieved. This is most likely a bug.\")  # type: ignore\n\n        if isinstance(result, str):\n            result = KiaraFileBundle.import_folder(source=result)\n\n    except NotImplementedError:\n        result = None\n\n    if not result:\n        result_file = model.retrieve(\n            uri=source, file_name=None, attach_metadata=attach_metadata\n        )\n        if not result_file:\n            raise KiaraException(msg=f\"Can't onboard file bundle from '{source}' using onboard type '{model_cls._kiara_model_id}': no result data retrieved. This is most likely a bug.\")  # type: ignore\n\n        if isinstance(result, str):\n            imported_bundle_file = KiaraFile.load_file(result_file)  # type: ignore\n        elif not isinstance(result_file, KiaraFile):\n            raise KiaraException(\n                \"Can't onboard file: onboard model returned data that is not a file. This is most likely a bug.\"\n            )\n        else:\n            imported_bundle_file = result_file\n\n        imported_bundle = KiaraFileBundle.from_archive_file(\n            imported_bundle_file, import_config=import_config\n        )\n    else:\n        imported_bundle = result\n\n    return imported_bundle\n</code></pre>"}]}